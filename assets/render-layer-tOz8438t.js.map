{"version":3,"file":"render-layer-tOz8438t.js","sources":["../../node_modules/solid-js/store/dist/store.js","../../node_modules/pixi.js/lib/filters/Filter.mjs","../../node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs","../../node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs","../../node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs","../../src/pages/demo/ordering/render-layer.tsx"],"sourcesContent":["import { $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes) Object.defineProperty(target, symbol, {\n    value: nodes = Object.create(null)\n  });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return nodes[property] = s;\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if (node = getNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || desc.set || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  desc.set = v => target[$PROXY][property] = v;\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    const proto = Object.getPrototypeOf(value);\n    const isClass = proto !== null && value !== null && typeof value === \"object\" && !Array.isArray(value) && proto !== Object.prototype;\n    if (isClass) {\n      const descriptors = Object.getOwnPropertyDescriptors(proto);\n      keys.push(...Object.keys(descriptors));\n      Object.assign(desc, descriptors);\n    }\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (isClass && prop === \"constructor\") continue;\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get,\n          configurable: true\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set,\n          configurable: true\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || isArray !== Array.isArray(previous) || key && target[key] !== previous[key])) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n      merge,\n      key = \"id\"\n    } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, proxy = new Proxy(state, setterTraps));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = undefined;\n\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","var fragment = \"\\nin vec2 vTextureCoord;\\nin vec2 vFilterUv;\\n\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\n\\nuniform vec4 uInputClamp;\\nuniform highp vec4 uInputSize;\\nuniform mat2 uRotation;\\nuniform vec2 uScale;\\n\\nvoid main()\\n{\\n    vec4 map = texture(uMapTexture, vFilterUv);\\n    \\n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \\n\\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=displacement.frag.mjs.map\n","var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 vFilterUv;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( void )\\n{\\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\\n}\\n\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n    vFilterUv = getFilterCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=displacement.vert.mjs.map\n","var source = \"\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct DisplacementUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uScale:vec2<f32>,\\n  uRotation:mat2x2<f32>\\n};\\n\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n\\n  \\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\\n\\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \\n   \\n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=displacement.wgsl.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport fragment from './displacement.frag.mjs';\nimport vertex from './displacement.vert.mjs';\nimport source from './displacement.wgsl.mjs';\n\n\"use strict\";\nclass DisplacementFilter extends Filter {\n  constructor(...args) {\n    let options = args[0];\n    if (options instanceof Sprite) {\n      if (args[1]) {\n        deprecation(v8_0_0, \"DisplacementFilter now uses options object instead of params. {sprite, scale}\");\n      }\n      options = { sprite: options, scale: args[1] };\n    }\n    const { sprite, scale: scaleOption, ...rest } = options;\n    let scale = scaleOption ?? 20;\n    if (typeof scale === \"number\") {\n      scale = new Point(scale, scale);\n    }\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uScale: { value: scale, type: \"vec2<f32>\" },\n      uRotation: { value: new Float32Array([0, 0, 0, 0]), type: \"mat2x2<f32>\" }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"displacement-filter\"\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const textureSource = sprite.texture.source;\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMapTexture: textureSource,\n        uMapSampler: textureSource.style\n      }\n    });\n    this._sprite = options.sprite;\n    this._sprite.renderable = false;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - clearMode.\n   */\n  apply(filterManager, input, output, clearMode) {\n    const uniforms = this.resources.filterUniforms.uniforms;\n    filterManager.calculateSpriteMatrix(\n      uniforms.uFilterMatrix,\n      this._sprite\n    );\n    const wt = this._sprite.worldTransform;\n    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n    if (lenX !== 0 && lenY !== 0) {\n      uniforms.uRotation[0] = wt.a / lenX;\n      uniforms.uRotation[1] = wt.b / lenX;\n      uniforms.uRotation[2] = wt.c / lenY;\n      uniforms.uRotation[3] = wt.d / lenY;\n    }\n    this.resources.uMapTexture = this._sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /** scaleX, scaleY for displacements */\n  get scale() {\n    return this.resources.filterUniforms.uniforms.uScale;\n  }\n}\n\nexport { DisplacementFilter };\n//# sourceMappingURL=DisplacementFilter.mjs.map\n","import * as PIXI from \"pixi.js\";\nimport {\n  Application,\n  Container,\n  Graphics,\n  onTick,\n  Sprite,\n  Text,\n  TilingSprite,\n} from \"@danneu/solid-pixi\";\nimport {\n  createResource,\n  createSignal,\n  Index,\n  Show,\n  Suspense,\n  type Component,\n} from \"solid-js\";\nimport { createStore, produce } from \"solid-js/store\";\n\nconst FishNameTag: Component<{ name: string; x: number; y: number }> = (\n  props\n) => {\n  const [labelSize, setLabelSize] = createSignal<\n    { width: number; height: number } | undefined\n  >(undefined);\n\n  const padding = 10;\n  return (\n    <Container x={props.x} y={props.y}>\n      <Show when={labelSize()}>\n        {(labelSize) => (\n          <Graphics\n            ref={(g) => {\n              g.roundRect(\n                -labelSize().width / 2 - padding,\n                -labelSize().height / 2 - padding,\n                labelSize().width + padding * 2,\n                labelSize().height + padding * 2,\n                20\n              ).fill({\n                color: 0xffff00,\n                alpha: 1,\n              });\n            }}\n          />\n        )}\n      </Show>\n      <Text\n        ref={(el) => {\n          setLabelSize({\n            width: el.width,\n            height: el.height,\n          });\n        }}\n        text={props.name}\n        anchor={0.5}\n        style={{\n          fontSize: 16,\n          fill: 0x000000,\n        }}\n      />\n    </Container>\n  );\n};\n\ntype Fish = {\n  name: string;\n  x: number;\n  y: number;\n  rotation: number;\n  direction: number;\n  speed: number;\n};\n\nconst useFishStore = () => {\n  const [fishes, setFishes] = createStore<Fish[]>([]);\n\n  const addFish = (name: string) => {\n    const fish: Fish = {\n      name,\n      x: Math.random() * 630,\n      y: Math.random() * 410,\n      rotation: 0,\n      direction: Math.random() * Math.PI * 2,\n      speed: 1 + Math.random(),\n    };\n    setFishes((prev) => [...prev, fish]);\n  };\n\n  const updateFish = (fish: Fish): Fish => {\n    fish.direction += 0.001;\n    fish.rotation = Math.PI - fish.direction;\n    fish.x += fish.speed * Math.cos(-fish.direction);\n    fish.y += fish.speed * Math.sin(-fish.direction);\n    // wrap around the screen\n    const padding = 100;\n    const width = 630;\n    const height = 410;\n    if (fish.x > width + padding) fish.x -= width + padding * 2;\n    if (fish.x < -padding) fish.x += width + padding * 2;\n    if (fish.y > height + padding) fish.y -= height + padding * 2;\n    if (fish.y < -padding) fish.y += height + padding * 2;\n    return fish;\n  };\n\n  const updateFishes = () => {\n    setFishes(produce((prev) => prev.map(updateFish)));\n  };\n\n  return [fishes, { addFish, updateFishes }] as const;\n};\n\nconst Pond: Component<{ textures: Record<string, PIXI.Texture> }> = (props) => {\n  const [fishes, { addFish, updateFishes }] = useFishStore();\n\n  const displacementMap = PIXI.Assets.get(\"displacementMap\");\n  displacementMap.source.wrapMode = \"repeat\";\n\n  const displacementSprite = PIXI.Sprite.from(displacementMap);\n  const displacementFilter = new PIXI.DisplacementFilter(\n    displacementSprite,\n    40\n  );\n\n  const [overlayPosition, setOverlayPosition] = createSignal({\n    x: 0,\n    y: 0,\n  });\n\n  onTick(() => {\n    setOverlayPosition((prev) => ({\n      x: prev.x + 0.5,\n      y: prev.y + 0.5,\n    }));\n\n    updateFishes();\n\n    displacementSprite.x += 0.5;\n    displacementSprite.y += 0.5;\n  });\n\n  for (let i = 0; i < 10; i++) {\n    addFish(`Fish ${i}`);\n  }\n\n  return (\n    <>\n      <Container filters={[displacementFilter]}>\n        <Sprite as={displacementSprite} />\n        <Sprite texture={props.textures.background} />\n        <TilingSprite\n          texture={props.textures.overlay}\n          width={630}\n          height={410}\n          tilePosition={overlayPosition()}\n        />\n        <Index each={fishes}>\n          {(fish) => {\n            return (\n              <Sprite\n                anchor={0.5}\n                texture={props.textures.fish1}\n                x={fish().x}\n                y={fish().y}\n                rotation={fish().rotation}\n              />\n            );\n          }}\n        </Index>\n      </Container>\n\n      {/* We render the name tags in their own container so that they aren't morphed  \n          by the displacement filter.\n\n          My wrapper doesn't have any conveniences for RenderLayer, so that solution\n          was too annoying to write (back to half-imperative pixi.js). \n      */}\n      <Container>\n        <Index each={fishes}>\n          {(fish) => {\n            return <FishNameTag name={fish().name} x={fish().x} y={fish().y} />;\n          }}\n        </Index>\n      </Container>\n    </>\n  );\n};\n\nexport default function () {\n  const [textures] = createResource(async () => {\n    return await PIXI.Assets.load<PIXI.Texture>([\n      {\n        alias: \"background\",\n        src: `https://pixijs.com/assets/pond/displacement_BG.jpg`,\n      },\n      { alias: \"overlay\", src: `https://pixijs.com/assets/pond/overlay.png` },\n      {\n        alias: \"displacementMap\",\n        src: `https://pixijs.com/assets/pond/displacement_map.png`,\n      },\n      {\n        alias: \"fish1\",\n        src: `https://pixijs.com/assets/pond/displacement_fish1.png`,\n      },\n      {\n        alias: \"fish2\",\n        src: `https://pixijs.com/assets/pond/displacement_fish2.png`,\n      },\n    ]);\n  });\n  return (\n    <>\n      <Suspense fallback={<div>Loading</div>}>\n        <Application antialias width={630} height={410}>\n          <Show when={textures()}>\n            {(textures) => {\n              return <Pond textures={textures()} />;\n            }}\n          </Show>\n        </Application>\n      </Suspense>\n    </>\n  );\n}\n"],"names":["_Filter","FishNameTag","props","labelSize","setLabelSize","createSignal","undefined","padding","_$createComponent","Container","x","y","children","Show","when","Graphics","ref","g","roundRect","width","height","fill","color","alpha","Text","el","text","name","anchor","style","fontSize","useFishStore","fishes","setFishes","createStore","addFish","fish","Math","random","rotation","direction","PI","speed","prev","updateFish","cos","sin","updateFishes","produce","map","Pond","displacementMap","PIXI","get","source","wrapMode","displacementSprite","from","displacementFilter","overlayPosition","setOverlayPosition","onTick","i","filters","Sprite","as","texture","textures","background","TilingSprite","overlay","tilePosition","Index","each","fish1","createResource","load","alias","src","Suspense","fallback","_tmpl$","Application","antialias"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}