{"version":3,"file":"Filter-DOpZEvp2.js","sources":["../../node_modules/pixi.js/lib/filters/Filter.mjs"],"sourcesContent":["import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n"],"names":["_Filter"],"mappings":";AAMA,MAAM,UAAU,MAAMA,iBAAgB,OAAO;AAAA;AAAA;AAAA;AAAA,EAI3C,YAAY,SAAS;AACnB,cAAU,EAAE,GAAGA,SAAQ,gBAAgB,GAAG,QAAS;AACnD,UAAM,OAAO;AAEb,SAAK,UAAU;AAMf,SAAK,SAAS,MAAM,MAAO;AAC3B,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AACvB,QAAI,OAAO,QAAQ,cAAc,WAAW;AAC1C,WAAK,YAAY,QAAQ,YAAY,OAAO;AAAA,IAClD,OAAW;AACL,WAAK,YAAY,QAAQ;AAAA,IAC/B;AACI,SAAK,aAAa,QAAQ;AAC1B,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,iBAAiB,QAAQ;AAC9B,SAAK,YAAY,YAAY,GAAG,CAAC;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,MAAM,eAAe,OAAO,QAAQ,WAAW;AAC7C,kBAAc,YAAY,MAAM,OAAO,QAAQ,SAAS;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,IAAI,YAAY;AACd,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA,EAEE,IAAI,UAAU,OAAO;AACnB,SAAK,OAAO,YAAY;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,OAAO,KAAK,SAAS;AACnB,UAAM,EAAE,KAAK,IAAI,GAAG,KAAM,IAAG;AAC7B,QAAI;AACJ,QAAI;AACJ,QAAI,KAAK;AACP,mBAAa,WAAW,KAAK,GAAG;AAAA,IACtC;AACI,QAAI,IAAI;AACN,kBAAY,UAAU,KAAK,EAAE;AAAA,IACnC;AACI,WAAO,IAAIA,SAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACT,CAAK;AAAA,EACL;AACA;AAKA,QAAQ,iBAAiB;AAAA,EACvB,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,WAAW;AAAA,EACX,eAAe;AAAA,EACf,gBAAgB;AAClB;AACG,IAAC,SAAS;","x_google_ignoreList":[0]}