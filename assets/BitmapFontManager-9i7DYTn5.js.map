{"version":3,"file":"BitmapFontManager-9i7DYTn5.js","sources":["../../node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs","../../node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs","../../node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs","../../node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs","../../node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs","../../node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs","../../node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs","../../node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nclass AbstractBitmapFont extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = \"\";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: \"none\", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    this.applyFillAsTint = true;\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    deprecation(v8_0_0, \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    deprecation(v8_0_0, \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture?.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\nexport { AbstractBitmapFont };\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { nextPow2 } from '../../../../maths/misc/pow2.mjs';\n\n\"use strict\";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext(\"2d\");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = nextPow2(minWidth);\n    minHeight = nextPow2(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    canvasAndContext.context.clearRect(0, 0, width, height);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\nexport { CanvasPool, CanvasPoolClass };\n//# sourceMappingURL=CanvasPool.mjs.map\n","\"use strict\";\nconst genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(\",\");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `\"${fontFamily}\"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\nexport { fontStringFromTextStyle };\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    const metrics = context.measureText(text);\n    let metricWidth = metrics.width;\n    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n    if (metricWidth > 0) {\n      if (useExperimentalLetterSpacing) {\n        metricWidth -= letterSpacing;\n        boundsWidth -= letterSpacing;\n      } else {\n        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        metricWidth += val;\n        boundsWidth += val;\n      }\n    }\n    return Math.max(metricWidth, boundsWidth);\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = DOMAdapter.get().createCanvas();\n      } catch (_cx) {\n        canvas = DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexport { CanvasTextMetrics };\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern.mjs';\n\n\"use strict\";\nconst PRECISION = 1e5;\nfunction getCanvasFillStyle(fillStyle, context, textMetrics, padding = 0) {\n  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {\n    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n    const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillPattern) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n    const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillGradient) {\n    const fillGradient = fillStyle.fill;\n    const isLinear = fillGradient.type === \"linear\";\n    const isLocal = fillGradient.textureSpace === \"local\";\n    let width = 1;\n    let height = 1;\n    if (isLocal && textMetrics) {\n      width = textMetrics.width + padding;\n      height = textMetrics.height + padding;\n    }\n    let gradient;\n    let isNearlyVertical = false;\n    if (isLinear) {\n      const { start, end } = fillGradient;\n      gradient = context.createLinearGradient(\n        start.x * width,\n        start.y * height,\n        end.x * width,\n        end.y * height\n      );\n      isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);\n    } else {\n      const { center, innerRadius, outerCenter, outerRadius } = fillGradient;\n      gradient = context.createRadialGradient(\n        center.x * width,\n        center.y * height,\n        innerRadius * width,\n        outerCenter.x * width,\n        outerCenter.y * height,\n        outerRadius * width\n      );\n    }\n    if (isNearlyVertical && isLocal && textMetrics) {\n      const ratio = textMetrics.lineHeight / height;\n      for (let i = 0; i < textMetrics.lines.length; i++) {\n        const start = (i * textMetrics.lineHeight + padding / 2) / height;\n        fillGradient.colorStops.forEach((stop) => {\n          const globalStop = start + stop.offset * ratio;\n          gradient.addColorStop(\n            // fix to 5 decimal places to avoid floating point precision issues\n            Math.floor(globalStop * PRECISION) / PRECISION,\n            Color.shared.setValue(stop.color).toHex()\n          );\n        });\n      }\n    } else {\n      fillGradient.colorStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n      });\n    }\n    return gradient;\n  }\n  warn(\"FillStyle not recognised\", fillStyle);\n  return \"red\";\n}\n\nexport { getCanvasFillStyle };\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n","\"use strict\";\nfunction resolveCharacters(chars) {\n  if (chars === \"\") {\n    return [];\n  }\n  if (typeof chars === \"string\") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  }\n  return result;\n}\n\nexport { resolveCharacters };\n//# sourceMappingURL=resolveCharacters.mjs.map\n","import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nconst _DynamicBitmapFont = class _DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 0;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = { ..._DynamicBitmapFont.defaultOptions, ...options };\n    this._textureSize = dynamicOptions.textureSize;\n    this._mipmap = dynamicOptions.mipmap;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    this.applyFillAsTint = dynamicOptions.overrideFill;\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    const maxTextureWidth = canvas.width / this.resolution;\n    const maxTextureHeight = canvas.height / this.resolution;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = metrics.width * fontScale;\n      const textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n      const height = metrics.height * fontScale;\n      const paddedWidth = textureGlyphWidth + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > maxTextureWidth) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > maxTextureHeight) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n      this._textureSize,\n      this._textureSize,\n      textureResolution\n    );\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        autoGenerateMipmaps: this._mipmap\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n};\n_DynamicBitmapFont.defaultOptions = {\n  textureSize: 512,\n  style: new TextStyle(),\n  mipmap: true\n};\nlet DynamicBitmapFont = _DynamicBitmapFont;\n\nexport { DynamicBitmapFont };\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n","\"use strict\";\nfunction getBitmapTextLayout(chars, style, font, trimEnd) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    if (trimEnd) {\n      let lastChar = currentLine.chars[index];\n      while (lastChar === \" \") {\n        currentLine.width -= font.chars[lastChar].xAdvance;\n        lastChar = currentLine.chars[--index];\n      }\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[\" \"];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === \"center\") {\n    alignCenter(layoutData);\n  } else if (style.align === \"right\") {\n    alignRight(layoutData);\n  } else if (style.align === \"justify\") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\nexport { getBitmapTextLayout };\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { DynamicBitmapFont } from './DynamicBitmapFont.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nlet fontCount = 0;\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [[\"0\", \"9\"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[\" \", \"~\"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill && !style._stroke) {\n      fontFamilyKey += style._fill.fill.styleKey;\n      overrideFill = false;\n    } else if (style._stroke || style.dropShadow) {\n      let key = style.styleKey;\n      key = key.substring(0, key.lastIndexOf(\"-\"));\n      fontFamilyKey = `${key}-bitmap`;\n      overrideFill = false;\n    }\n    if (!Cache.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fontCount++;\n      if (fontCount > 50) {\n        warn(\"BitmapText\", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n      }\n      fnt.once(\"destroy\", () => {\n        fontCount--;\n        Cache.remove(fontFamilyKey);\n      });\n      Cache.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  getLayout(text, style, trimEnd = true) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  measureText(text, style, trimEnd = true) {\n    return this.getLayout(text, style, trimEnd);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === \"string\") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      deprecation(v8_0_0, \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(\"\"));\n    Cache.set(`${name}-bitmap`, font);\n    font.once(\"destroy\", () => Cache.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache.get(cacheKey);\n    if (font) {\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\nexport { BitmapFontManager };\n//# sourceMappingURL=BitmapFontManager.mjs.map\n"],"names":["_CanvasTextMetrics","_DynamicBitmapFont"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}