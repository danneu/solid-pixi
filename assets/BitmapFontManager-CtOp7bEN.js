import{E as Q,d as T,v as y,D as W,n as H,T as P,C as I,M as j,w as V,R as ee,I as te,a as k}from"./index-D5v0L9fs.js";import{T as E}from"./TextStyle-TwOkpUy_.js";import{b as ne,F as ie}from"./GraphicsContext-CDVTt8yM.js";class se extends Q{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return T(y,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return T(y,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return T(y,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return T(y,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return T(y,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){var e;this.emit("destroy",this),this.removeAllListeners();for(const n in this.chars)(e=this.chars[n].texture)==null||e.destroy();this.chars=null,t&&(this.pages.forEach(n=>n.texture.destroy(!0)),this.pages=null)}}class ae{constructor(t){this._canvasPool=Object.create(null),this.canvasOptions=t||{},this.enableFullScreen=!1}_createCanvasAndContext(t,e){const n=W.get().createCanvas();n.width=t,n.height=e;const i=n.getContext("2d");return{canvas:n,context:i}}getOptimalCanvasAndContext(t,e,n=1){t=Math.ceil(t*n-1e-6),e=Math.ceil(e*n-1e-6),t=H(t),e=H(e);const i=(t<<17)+(e<<1);this._canvasPool[i]||(this._canvasPool[i]=[]);let s=this._canvasPool[i].pop();return s||(s=this._createCanvasAndContext(t,e)),s}returnCanvasAndContext(t){const e=t.canvas,{width:n,height:i}=e,s=(n<<17)+(i<<1);t.context.clearRect(0,0,n,i),this._canvasPool[s].push(t)}clear(){this._canvasPool={}}}const N=new ae,re=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function O(c){const t=typeof c.fontSize=="number"?`${c.fontSize}px`:c.fontSize;let e=c.fontFamily;Array.isArray(c.fontFamily)||(e=c.fontFamily.split(","));for(let n=e.length-1;n>=0;n--){let i=e[n].trim();!/([\"\'])[^\'\"]+\1/.test(i)&&!re.includes(i)&&(i=`"${i}"`),e[n]=i}return`${c.fontStyle} ${c.fontVariant} ${c.fontWeight} ${t} ${e.join(",")}`}const R={willReadFrequently:!0},v=class o{static get experimentalLetterSpacingSupported(){let t=o._experimentalLetterSpacingSupported;if(t!==void 0){const e=W.get().getCanvasRenderingContext2D().prototype;t=o._experimentalLetterSpacingSupported="letterSpacing"in e||"textLetterSpacing"in e}return t}constructor(t,e,n,i,s,a,r,h,l){this.text=t,this.style=e,this.width=n,this.height=i,this.lines=s,this.lineWidths=a,this.lineHeight=r,this.maxLineWidth=h,this.fontProperties=l}static measureText(t=" ",e,n=o._canvas,i=e.wordWrap){var C;const s=`${t}:${e.styleKey}`;if(o._measurementCache[s])return o._measurementCache[s];const a=O(e),r=o.measureFont(a);r.fontSize===0&&(r.fontSize=e.fontSize,r.ascent=e.fontSize);const h=o.__context;h.font=a;const d=(i?o._wordWrap(t,e,n):t).split(/(?:\r\n|\r|\n)/),p=new Array(d.length);let u=0;for(let m=0;m<d.length;m++){const x=o._measureText(d[m],e.letterSpacing,h);p[m]=x,u=Math.max(u,x)}const w=((C=e._stroke)==null?void 0:C.width)||0;let f=u+w;e.dropShadow&&(f+=e.dropShadow.distance);const g=e.lineHeight||r.fontSize;let S=Math.max(g,r.fontSize+w)+(d.length-1)*(g+e.leading);return e.dropShadow&&(S+=e.dropShadow.distance),new o(t,e,f,S,d,p,g+e.leading,u,r)}static _measureText(t,e,n){let i=!1;o.experimentalLetterSpacingSupported&&(o.experimentalLetterSpacing?(n.letterSpacing=`${e}px`,n.textLetterSpacing=`${e}px`,i=!0):(n.letterSpacing="0px",n.textLetterSpacing="0px"));const s=n.measureText(t);let a=s.width;const r=-s.actualBoundingBoxLeft;let l=s.actualBoundingBoxRight-r;if(a>0)if(i)a-=e,l-=e;else{const d=(o.graphemeSegmenter(t).length-1)*e;a+=d,l+=d}return Math.max(a,l)}static _wordWrap(t,e,n=o._canvas){const i=n.getContext("2d",R);let s=0,a="",r="";const h=Object.create(null),{letterSpacing:l,whiteSpace:d}=e,p=o._collapseSpaces(d),u=o._collapseNewlines(d);let w=!p;const f=e.wordWrapWidth+l,g=o._tokenize(t);for(let S=0;S<g.length;S++){let _=g[S];if(o._isNewline(_)){if(!u){r+=o._addLine(a),w=!p,a="",s=0;continue}_=" "}if(p){const m=o.isBreakingSpace(_),x=o.isBreakingSpace(a[a.length-1]);if(m&&x)continue}const C=o._getFromCache(_,l,h,i);if(C>f)if(a!==""&&(r+=o._addLine(a),a="",s=0),o.canBreakWords(_,e.breakWords)){const m=o.wordWrapSplit(_);for(let x=0;x<m.length;x++){let F=m[x],A=F,L=1;for(;m[x+L];){const B=m[x+L];if(!o.canBreakChars(A,B,_,x,e.breakWords))F+=B;else break;A=B,L++}x+=L-1;const z=o._getFromCache(F,l,h,i);z+s>f&&(r+=o._addLine(a),w=!1,a="",s=0),a+=F,s+=z}}else{a.length>0&&(r+=o._addLine(a),a="",s=0);const m=S===g.length-1;r+=o._addLine(_,!m),w=!1,a="",s=0}else C+s>f&&(w=!1,r+=o._addLine(a),a="",s=0),(a.length>0||!o.isBreakingSpace(_)||w)&&(a+=_,s+=C)}return r+=o._addLine(a,!1),r}static _addLine(t,e=!0){return t=o._trimRight(t),t=e?`${t}
`:t,t}static _getFromCache(t,e,n,i){let s=n[t];return typeof s!="number"&&(s=o._measureText(t,e,i)+e,n[t]=s),s}static _collapseSpaces(t){return t==="normal"||t==="pre-line"}static _collapseNewlines(t){return t==="normal"}static _trimRight(t){if(typeof t!="string")return"";for(let e=t.length-1;e>=0;e--){const n=t[e];if(!o.isBreakingSpace(n))break;t=t.slice(0,-1)}return t}static _isNewline(t){return typeof t!="string"?!1:o._newlines.includes(t.charCodeAt(0))}static isBreakingSpace(t,e){return typeof t!="string"?!1:o._breakingSpaces.includes(t.charCodeAt(0))}static _tokenize(t){const e=[];let n="";if(typeof t!="string")return e;for(let i=0;i<t.length;i++){const s=t[i],a=t[i+1];if(o.isBreakingSpace(s,a)||o._isNewline(s)){n!==""&&(e.push(n),n=""),e.push(s);continue}n+=s}return n!==""&&e.push(n),e}static canBreakWords(t,e){return e}static canBreakChars(t,e,n,i,s){return!0}static wordWrapSplit(t){return o.graphemeSegmenter(t)}static measureFont(t){if(o._fonts[t])return o._fonts[t];const e=o._context;e.font=t;const n=e.measureText(o.METRICS_STRING+o.BASELINE_SYMBOL),i={ascent:n.actualBoundingBoxAscent,descent:n.actualBoundingBoxDescent,fontSize:n.actualBoundingBoxAscent+n.actualBoundingBoxDescent};return o._fonts[t]=i,i}static clearMetrics(t=""){t?delete o._fonts[t]:o._fonts={}}static get _canvas(){if(!o.__canvas){let t;try{const e=new OffscreenCanvas(0,0),n=e.getContext("2d",R);if(n!=null&&n.measureText)return o.__canvas=e,e;t=W.get().createCanvas()}catch{t=W.get().createCanvas()}t.width=t.height=10,o.__canvas=t}return o.__canvas}static get _context(){return o.__context||(o.__context=o._canvas.getContext("2d",R)),o.__context}};v.METRICS_STRING="|ÉqÅ";v.BASELINE_SYMBOL="M";v.BASELINE_MULTIPLIER=1.4;v.HEIGHT_MULTIPLIER=2;v.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const c=new Intl.Segmenter;return t=>[...c.segment(t)].map(e=>e.segment)}return c=>[...c]})();v.experimentalLetterSpacing=!1;v._fonts={};v._newlines=[10,13];v._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288];v._measurementCache={};let K=v;const G=1e5;function Y(c,t,e,n=0){if(c.texture===P.WHITE&&!c.fill)return I.shared.setValue(c.color).setAlpha(c.alpha??1).toHexa();if(c.fill){if(c.fill instanceof ne){const i=c.fill,s=t.createPattern(i.texture.source.resource,"repeat"),a=i.transform.copyTo(j.shared);return a.scale(i.texture.frame.width,i.texture.frame.height),s.setTransform(a),s}else if(c.fill instanceof ie){const i=c.fill,s=i.type==="linear",a=i.textureSpace==="local";let r=1,h=1;a&&e&&(r=e.width+n,h=e.height+n);let l,d=!1;if(s){const{start:p,end:u}=i;l=t.createLinearGradient(p.x*r,p.y*h,u.x*r,u.y*h),d=Math.abs(u.x-p.x)<Math.abs((u.y-p.y)*.1)}else{const{center:p,innerRadius:u,outerCenter:w,outerRadius:f}=i;l=t.createRadialGradient(p.x*r,p.y*h,u*r,w.x*r,w.y*h,f*r)}if(d&&a&&e){const p=e.lineHeight/h;for(let u=0;u<e.lines.length;u++){const w=(u*e.lineHeight+n/2)/h;i.colorStops.forEach(f=>{const g=w+f.offset*p;l.addColorStop(Math.floor(g*G)/G,I.shared.setValue(f.color).toHex())})}}else i.colorStops.forEach(p=>{l.addColorStop(p.offset,I.shared.setValue(p.color).toHex())});return l}}else{const i=t.createPattern(c.texture.source.resource,"repeat"),s=c.matrix.copyTo(j.shared);return s.scale(c.texture.frame.width,c.texture.frame.height),i.setTransform(s),i}return V("FillStyle not recognised",c),"red"}function X(c){if(c==="")return[];typeof c=="string"&&(c=[c]);const t=[];for(let e=0,n=c.length;e<n;e++){const i=c[e];if(Array.isArray(i)){if(i.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);if(i[0].length===0||i[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const s=i[0].charCodeAt(0),a=i[1].charCodeAt(0);if(a<s)throw new Error("[BitmapFont]: Invalid character range.");for(let r=s,h=a;r<=h;r++)t.push(String.fromCharCode(r))}else t.push(...Array.from(i))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}const U=class q extends se{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const e={...q.defaultOptions,...t};this._textureSize=e.textureSize,this._mipmap=e.mipmap;const n=e.style.clone();e.overrideFill&&(n._fill.color=16777215,n._fill.alpha=1,n._fill.texture=P.WHITE,n._fill.fill=null),this.applyFillAsTint=e.overrideFill;const i=n.fontSize;n.fontSize=this.baseMeasurementFontSize;const s=O(n);e.overrideSize?n._stroke&&(n._stroke.width*=this.baseRenderedFontSize/i):n.fontSize=this.baseRenderedFontSize=i,this._style=n,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,this.fontMetrics=K.measureFont(s),this.lineHeight=n.lineHeight||this.fontMetrics.fontSize||n.fontSize}ensureCharacters(t){var S,_;const e=X(t).filter(C=>!this._currentChars.includes(C)).filter((C,m,x)=>x.indexOf(C)===m);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let n;this._currentPageIndex===-1?n=this._nextPage():n=this.pages[this._currentPageIndex];let{canvas:i,context:s}=n.canvasAndContext,a=n.texture.source;const r=this._style;let h=this._currentX,l=this._currentY;const d=this.baseRenderedFontSize/this.baseMeasurementFontSize,p=this._padding*d;let u=0,w=!1;const f=i.width/this.resolution,g=i.height/this.resolution;for(let C=0;C<e.length;C++){const m=e[C],x=K.measureText(m,r,i,!1);x.lineHeight=x.height;const F=x.width*d,A=Math.ceil((r.fontStyle==="italic"?2:1)*F),L=x.height*d,z=A+p*2,B=L+p*2;if(w=!1,m!==`
`&&m!=="\r"&&m!=="	"&&m!==" "&&(w=!0,u=Math.ceil(Math.max(B,u))),h+z>f&&(l+=u,u=B,h=0,l+u>g)){a.update();const b=this._nextPage();i=b.canvasAndContext.canvas,s=b.canvasAndContext.context,a=b.texture.source,l=0}const J=F/d-(((S=r.dropShadow)==null?void 0:S.distance)??0)-(((_=r._stroke)==null?void 0:_.width)??0);if(this.chars[m]={id:m.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:J,kerning:{}},w){this._drawGlyph(s,x,h+p,l+p,d,r);const b=a.width*d,$=a.height*d,Z=new ee(h/b*a.width,l/$*a.height,z/b*a.width,B/$*a.height);this.chars[m].texture=new P({source:a,frame:Z}),h+=Math.ceil(z)}}a.update(),this._currentX=h,this._currentY=l,this._skipKerning&&this._applyKerning(e,s)}get pageTextures(){return T(y,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const n=this._measureCache;for(let i=0;i<t.length;i++){const s=t[i];for(let a=0;a<this._currentChars.length;a++){const r=this._currentChars[a];let h=n[s];h||(h=n[s]=e.measureText(s).width);let l=n[r];l||(l=n[r]=e.measureText(r).width);let d=e.measureText(s+r).width,p=d-(h+l);p&&(this.chars[s].kerning[r]=p),d=e.measureText(s+r).width,p=d-(h+l),p&&(this.chars[r].kerning[s]=p)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=N.getOptimalCanvasAndContext(this._textureSize,this._textureSize,t);this._setupContext(e.context,this._style,t);const n=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),i=new P({source:new te({resource:e.canvas,resolution:n,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})}),s={canvasAndContext:e,texture:i};return this.pages[this._currentPageIndex]=s,s}_setupContext(t,e,n){e.fontSize=this.baseRenderedFontSize,t.scale(n,n),t.font=O(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const i=e._stroke,s=(i==null?void 0:i.width)??0;if(i&&(t.lineWidth=s,t.lineJoin=i.join,t.miterLimit=i.miterLimit,t.strokeStyle=Y(i,t)),e._fill&&(t.fillStyle=Y(e._fill,t)),e.dropShadow){const a=e.dropShadow,r=I.shared.setValue(a.color).toArray(),h=a.blur*n,l=a.distance*n;t.shadowColor=`rgba(${r[0]*255},${r[1]*255},${r[2]*255},${a.alpha})`,t.shadowBlur=h,t.shadowOffsetX=Math.cos(a.angle)*l,t.shadowOffsetY=Math.sin(a.angle)*l}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,n,i,s,a){const r=e.text,h=e.fontProperties,l=a._stroke,d=((l==null?void 0:l.width)??0)*s,p=n+d/2,u=i-d/2,w=h.descent*s,f=e.lineHeight*s;a.stroke&&d&&t.strokeText(r,p,u+f-w),a._fill&&t.fillText(r,p,u+f-w)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:n}=this.pages[t];N.returnCanvasAndContext(e),n.destroy(!0)}this.pages=null}};U.defaultOptions={textureSize:512,style:new E,mipmap:!0};let D=U;function oe(c,t,e,n){const i={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};i.offsetY=e.baseLineOffset;let s=i.lines[0],a=null,r=!0;const h={width:0,start:0,index:0,positions:[],chars:[]},l=f=>{const g=s.width;for(let S=0;S<h.index;S++){const _=f.positions[S];s.chars.push(f.chars[S]),s.charPositions.push(_+g)}s.width+=f.width,r=!1,h.width=0,h.index=0,h.chars.length=0},d=()=>{let f=s.chars.length-1;if(n){let g=s.chars[f];for(;g===" ";)s.width-=e.chars[g].xAdvance,g=s.chars[--f]}i.width=Math.max(i.width,s.width),s={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},r=!0,i.lines.push(s),i.height+=e.lineHeight},p=e.baseMeasurementFontSize/t.fontSize,u=t.letterSpacing*p,w=t.wordWrapWidth*p;for(let f=0;f<c.length+1;f++){let g;const S=f===c.length;S||(g=c[f]);const _=e.chars[g]||e.chars[" "];if(/(?:\s)/.test(g)||g==="\r"||g===`
`||S){if(!r&&t.wordWrap&&s.width+h.width-u>w?(d(),l(h),S||s.charPositions.push(0)):(h.start=s.width,l(h),S||s.charPositions.push(0)),g==="\r"||g===`
`)s.width!==0&&d();else if(!S){const F=_.xAdvance+(_.kerning[a]||0)+u;s.width+=F,s.spaceWidth=F,s.spacesIndex.push(s.charPositions.length),s.chars.push(g)}}else{const x=_.kerning[a]||0,F=_.xAdvance+x+u;h.positions[h.index++]=h.width+x,h.chars.push(g),h.width+=F}a=g}return d(),t.align==="center"?ce(i):t.align==="right"?he(i):t.align==="justify"&&le(i),i}function ce(c){for(let t=0;t<c.lines.length;t++){const e=c.lines[t],n=c.width/2-e.width/2;for(let i=0;i<e.charPositions.length;i++)e.charPositions[i]+=n}}function he(c){for(let t=0;t<c.lines.length;t++){const e=c.lines[t],n=c.width-e.width;for(let i=0;i<e.charPositions.length;i++)e.charPositions[i]+=n}}function le(c){const t=c.width;for(let e=0;e<c.lines.length;e++){const n=c.lines[e];let i=0,s=n.spacesIndex[i++],a=0;const r=n.spacesIndex.length,l=(t-n.width)/r;for(let d=0;d<n.charPositions.length;d++)d===s&&(s=n.spacesIndex[i++],a+=l),n.charPositions[d]+=a}}let M=0;class de{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(t,e){var a;let n=`${e.fontFamily}-bitmap`,i=!0;if(e._fill.fill&&!e._stroke)n+=e._fill.fill.styleKey,i=!1;else if(e._stroke||e.dropShadow){let r=e.styleKey;r=r.substring(0,r.lastIndexOf("-")),n=`${r}-bitmap`,i=!1}if(!k.has(n)){const r=new D({style:e,overrideFill:i,overrideSize:!0,...this.defaultOptions});M++,M>50&&V("BitmapText",`You have dynamically created ${M} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),r.once("destroy",()=>{M--,k.remove(n)}),k.set(n,r)}const s=k.get(n);return(a=s.ensureCharacters)==null||a.call(s,t),s}getLayout(t,e,n=!0){const i=this.getFont(t,e);return oe([...t],e,i,n)}measureText(t,e,n=!0){return this.getLayout(t,e,n)}install(...t){var l,d,p,u;let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:(l=t[2])==null?void 0:l.chars,resolution:(d=t[2])==null?void 0:d.resolution,padding:(p=t[2])==null?void 0:p.padding,skipKerning:(u=t[2])==null?void 0:u.skipKerning},T(y,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const n=e==null?void 0:e.name;if(!n)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const i=e.style,s=i instanceof E?i:new E(i),a=s._fill.fill!==null&&s._fill.fill!==void 0,r=new D({style:s,overrideFill:a,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1}),h=X(e.chars);return r.ensureCharacters(h.join("")),k.set(`${n}-bitmap`,r),r.once("destroy",()=>k.remove(`${n}-bitmap`)),r}uninstall(t){const e=`${t}-bitmap`,n=k.get(e);n&&n.destroy()}}const ge=new de;export{se as A,ge as B,N as C,K as a,Y as b,O as f,oe as g};
