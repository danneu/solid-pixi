import{D as Ue,u as D,E as Mt,m as ys,C as H,T as N,I as ae,M as V,d as Ot,w as Z,R as q,B as Yt,b as L,o as xs,P as J,q as bs,s as ut,e as He,t as _s,x as Ss,v as Ps}from"./index-DO3mo0dA.js";import{am as vs}from"./pixi-IUmcjyjd.js";const kt=Object.create(null),ce=Object.create(null);function Xt(i,t){let e=ce[i];return e===void 0&&(kt[t]===void 0&&(kt[t]=1),ce[i]=e=kt[t]++),e}let K;function Ne(){return(!K||K!=null&&K.isContextLost())&&(K=Ue.get().createCanvas().getContext("webgl",{})),K}let bt;function Ms(){if(!bt){bt="mediump";const i=Ne();i&&i.getShaderPrecisionFormat&&(bt=i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.HIGH_FLOAT).precision?"highp":"mediump")}return bt}function ws(i,t,e){return t?i:e?(i=i.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `}function Ts(i,t,e){const s=e?t.maxSupportedFragmentPrecision:t.maxSupportedVertexPrecision;if(i.substring(0,9)!=="precision"){let r=e?t.requestedFragmentPrecision:t.requestedVertexPrecision;return r==="highp"&&s!=="highp"&&(r="mediump"),`precision ${r} float;
${i}`}else if(s!=="highp"&&i.substring(0,15)==="precision highp")return i.replace("precision highp","precision mediump");return i}function Cs(i,t){return t?`#version 300 es
${i}`:i}const ks={},Is={};function As(i,{name:t="pixi-program"},e=!0){t=t.replace(/\s+/g,"-"),t+=e?"-fragment":"-vertex";const s=e?ks:Is;return s[t]?(s[t]++,t+=`-${s[t]}`):s[t]=1,i.indexOf("#define SHADER_NAME")!==-1?i:`${`#define SHADER_NAME ${t}`}
${i}`}function zs(i,t){return t?i.replace("#version 300 es",""):i}const It={stripVersion:zs,ensurePrecision:Ts,addProgramDefines:ws,setProgramName:As,insertVersion:Cs},At=Object.create(null),qe=class $t{constructor(t){t={...$t.defaultOptions,...t};const e=t.fragment.indexOf("#version 300 es")!==-1,s={stripVersion:e,ensurePrecision:{requestedFragmentPrecision:t.preferredFragmentPrecision,requestedVertexPrecision:t.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:Ms()},setProgramName:{name:t.name},addProgramDefines:e,insertVersion:e};let r=t.fragment,n=t.vertex;Object.keys(It).forEach(o=>{const a=s[o];r=It[o](r,a,!0),n=It[o](n,a,!1)}),this.fragment=r,this.vertex=n,this.transformFeedbackVaryings=t.transformFeedbackVaryings,this._key=Xt(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(t){const e=`${t.vertex}:${t.fragment}`;return At[e]||(At[e]=new $t(t)),At[e]}};qe.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let je=qe;const he={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function Es(i){return he[i]??he.float32}const Bs={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function Gs({source:i,entryPoint:t}){const e={},s=i.indexOf(`fn ${t}`);if(s!==-1){const r=i.indexOf("->",s);if(r!==-1){const n=i.substring(s,r),o=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let a;for(;(a=o.exec(n))!==null;){const h=Bs[a[3]]??"float32";e[a[2]]={location:parseInt(a[1],10),format:h,stride:Es(h).stride,offset:0,instance:!1,start:0}}}}return e}function zt(i){var d,f;const t=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,e=/@group\((\d+)\)/,s=/@binding\((\d+)\)/,r=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,o=/struct\s+(\w+)\s*{([^}]+)}/g,a=/(\w+)\s*:\s*([\w\<\>]+)/g,h=/struct\s+(\w+)/,u=(d=i.match(t))==null?void 0:d.map(l=>({group:parseInt(l.match(e)[1],10),binding:parseInt(l.match(s)[1],10),name:l.match(r)[2],isUniform:l.match(r)[1]==="<uniform>",type:l.match(n)[1]}));if(!u)return{groups:[],structs:[]};const c=((f=i.match(o))==null?void 0:f.map(l=>{const p=l.match(h)[1],g=l.match(a).reduce((m,x)=>{const[y,P]=x.split(":");return m[y.trim()]=P.trim(),m},{});return g?{name:p,members:g}:null}).filter(({name:l})=>u.some(p=>p.type===l)))??[];return{groups:u,structs:c}}var ct=(i=>(i[i.VERTEX=1]="VERTEX",i[i.FRAGMENT=2]="FRAGMENT",i[i.COMPUTE=4]="COMPUTE",i))(ct||{});function Rs({groups:i}){const t=[];for(let e=0;e<i.length;e++){const s=i[e];t[s.group]||(t[s.group]=[]),s.isUniform?t[s.group].push({binding:s.binding,visibility:ct.VERTEX|ct.FRAGMENT,buffer:{type:"uniform"}}):s.type==="sampler"?t[s.group].push({binding:s.binding,visibility:ct.FRAGMENT,sampler:{type:"filtering"}}):s.type==="texture_2d"&&t[s.group].push({binding:s.binding,visibility:ct.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return t}function Ds({groups:i}){const t=[];for(let e=0;e<i.length;e++){const s=i[e];t[s.group]||(t[s.group]={}),t[s.group][s.name]=s.binding}return t}function Fs(i,t){const e=new Set,s=new Set,r=[...i.structs,...t.structs].filter(o=>e.has(o.name)?!1:(e.add(o.name),!0)),n=[...i.groups,...t.groups].filter(o=>{const a=`${o.name}-${o.binding}`;return s.has(a)?!1:(s.add(a),!0)});return{structs:r,groups:n}}const Et=Object.create(null);class wt{constructor(t){var a,h;this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:e,vertex:s,layout:r,gpuLayout:n,name:o}=t;if(this.name=o,this.fragment=e,this.vertex=s,e.source===s.source){const u=zt(e.source);this.structsAndGroups=u}else{const u=zt(s.source),c=zt(e.source);this.structsAndGroups=Fs(u,c)}this.layout=r??Ds(this.structsAndGroups),this.gpuLayout=n??Rs(this.structsAndGroups),this.autoAssignGlobalUniforms=((a=this.layout[0])==null?void 0:a.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((h=this.layout[1])==null?void 0:h.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:t,fragment:e}=this,s=t.source+e.source+t.entryPoint+e.entryPoint;this._layoutKey=Xt(s,"program")}get attributeData(){return this._attributeData??(this._attributeData=Gs(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(t){const e=`${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;return Et[e]||(Et[e]=new wt(t)),Et[e]}}const We=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>","vec2<i32>","vec3<i32>","vec4<i32>"],Vs=We.reduce((i,t)=>(i[t]=!0,i),{});function Ls(i,t){switch(i){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*t);case"vec3<f32>":return new Float32Array(3*t);case"vec4<f32>":return new Float32Array(4*t);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const Oe=class Ye{constructor(t,e){this._touched=0,this.uid=D("uniform"),this._resourceType="uniformGroup",this._resourceId=D("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,e={...Ye.defaultOptions,...e},this.uniformStructures=t;const s={};for(const r in t){const n=t[r];if(n.name=r,n.size=n.size??1,!Vs[n.type])throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${We.join(", ")}`);n.value??(n.value=Ls(n.type,n.size)),s[r]=n.value}this.uniforms=s,this._dirtyId=1,this.ubo=e.ubo,this.isStatic=e.isStatic,this._signature=Xt(Object.keys(s).map(r=>`${r}-${t[r].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};Oe.defaultOptions={ubo:!1,isStatic:!1};let Xe=Oe;class Pt{constructor(t){this.resources=Object.create(null),this._dirty=!0;let e=0;for(const s in t){const r=t[s];this.setResource(r,e++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const t=[];let e=0;for(const s in this.resources)t[e++]=this.resources[s]._resourceId;this._key=t.join("|")}setResource(t,e){var r,n;const s=this.resources[e];t!==s&&(s&&((r=t.off)==null||r.call(t,"change",this.onResourceChange,this)),(n=t.on)==null||n.call(t,"change",this.onResourceChange,this),this.resources[e]=t,this._dirty=!0)}getResource(t){return this.resources[t]}_touch(t){const e=this.resources;for(const s in e)e[s]._touched=t}destroy(){var e;const t=this.resources;for(const s in t){const r=t[s];(e=r.off)==null||e.call(r,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(t){if(this._dirty=!0,t.destroyed){const e=this.resources;for(const s in e)e[s]===t&&(e[s]=null)}else this._updateKey()}}var Ut=(i=>(i[i.WEBGL=1]="WEBGL",i[i.WEBGPU=2]="WEBGPU",i[i.BOTH=3]="BOTH",i))(Ut||{});class Kt extends Mt{constructor(t){super(),this.uid=D("shader"),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:e,glProgram:s,groups:r,resources:n,compatibleRenderers:o,groupMap:a}=t;this.gpuProgram=e,this.glProgram=s,o===void 0&&(o=0,e&&(o|=Ut.WEBGPU),s&&(o|=Ut.WEBGL)),this.compatibleRenderers=o;const h={};if(!n&&!r&&(n={}),n&&r)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&r&&!a)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&r&&a)for(const u in a)for(const c in a[u]){const d=a[u][c];h[d]={group:u,binding:c,name:d}}else if(e&&r&&!a){const u=e.structsAndGroups.groups;a={},u.forEach(c=>{a[c.group]=a[c.group]||{},a[c.group][c.binding]=c.name,h[c.name]=c})}else if(n){r={},a={},e&&e.structsAndGroups.groups.forEach(d=>{a[d.group]=a[d.group]||{},a[d.group][d.binding]=d.name,h[d.name]=d});let u=0;for(const c in n)h[c]||(r[99]||(r[99]=new Pt,this._ownedBindGroups.push(r[99])),h[c]={group:99,binding:u,name:c},a[99]=a[99]||{},a[99][u]=c,u++);for(const c in n){const d=c;let f=n[c];!f.source&&!f._resourceType&&(f=new Xe(f));const l=h[d];l&&(r[l.group]||(r[l.group]=new Pt,this._ownedBindGroups.push(r[l.group])),r[l.group].setResource(f,l.binding))}}this.groups=r,this._uniformBindMap=a,this.resources=this._buildResourceAccessor(r,h)}addResource(t,e,s){var r,n;(r=this._uniformBindMap)[e]||(r[e]={}),(n=this._uniformBindMap[e])[s]||(n[s]=t),this.groups[e]||(this.groups[e]=new Pt,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(t,e){const s={};for(const r in e){const n=e[r];Object.defineProperty(s,n.name,{get(){return t[n.group].getResource(n.binding)},set(o){t[n.group].setResource(o,n.binding)}})}return s}destroy(t=!1){var e,s;this.emit("destroy",this),t&&((e=this.gpuProgram)==null||e.destroy(),(s=this.glProgram)==null||s.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(r=>{r.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(t){const{gpu:e,gl:s,...r}=t;let n,o;return e&&(n=wt.from(e)),s&&(o=je.from(s)),new Kt({gpuProgram:n,glProgram:o,...r})}}const ue=[{offset:0,color:"white"},{offset:1,color:"black"}],Qt=class Ht{constructor(...t){this.uid=D("fillGradient"),this.type="linear",this.colorStops=[];let e=$s(t);e={...e.type==="radial"?Ht.defaultRadialOptions:Ht.defaultLinearOptions,...ys(e)},this._textureSize=e.textureSize,this._wrapMode=e.wrapMode,e.type==="radial"?(this.center=e.center,this.outerCenter=e.outerCenter??this.center,this.innerRadius=e.innerRadius,this.outerRadius=e.outerRadius,this.scale=e.scale,this.rotation=e.rotation):(this.start=e.start,this.end=e.end),this.textureSpace=e.textureSpace,this.type=e.type,e.colorStops.forEach(r=>{this.addColorStop(r.offset,r.color)})}addColorStop(t,e){return this.colorStops.push({offset:t,color:H.shared.setValue(e).toHexa()}),this}buildLinearGradient(){if(this.texture)return;let{x:t,y:e}=this.start,{x:s,y:r}=this.end,n=s-t,o=r-e;const a=n<0||o<0;if(this._wrapMode==="clamp-to-edge"){if(n<0){const m=t;t=s,s=m,n*=-1}if(o<0){const m=e;e=r,r=m,o*=-1}}const h=this.colorStops.length?this.colorStops:ue,u=this._textureSize,{canvas:c,context:d}=de(u,1),f=a?d.createLinearGradient(this._textureSize,0,0,0):d.createLinearGradient(0,0,this._textureSize,0);le(f,h),d.fillStyle=f,d.fillRect(0,0,u,1),this.texture=new N({source:new ae({resource:c,addressMode:this._wrapMode})});const l=Math.sqrt(n*n+o*o),p=Math.atan2(o,n),g=new V;g.scale(l/u,1),g.rotate(p),g.translate(t,e),this.textureSpace==="local"&&g.scale(u,u),this.transform=g}buildGradient(){this.type==="linear"?this.buildLinearGradient():this.buildRadialGradient()}buildRadialGradient(){if(this.texture)return;const t=this.colorStops.length?this.colorStops:ue,e=this._textureSize,{canvas:s,context:r}=de(e,e),{x:n,y:o}=this.center,{x:a,y:h}=this.outerCenter,u=this.innerRadius,c=this.outerRadius,d=a-c,f=h-c,l=e/(c*2),p=(n-d)*l,g=(o-f)*l,m=r.createRadialGradient(p,g,u*l,(a-d)*l,(h-f)*l,c*l);le(m,t),r.fillStyle=t[t.length-1].color,r.fillRect(0,0,e,e),r.fillStyle=m,r.translate(p,g),r.rotate(this.rotation),r.scale(1,this.scale),r.translate(-p,-g),r.fillRect(0,0,e,e),this.texture=new N({source:new ae({resource:s,addressMode:this._wrapMode})});const x=new V;x.scale(1/l,1/l),x.translate(d,f),this.textureSpace==="local"&&x.scale(e,e),this.transform=x}get styleKey(){return this.uid}destroy(){var t;(t=this.texture)==null||t.destroy(!0),this.texture=null}};Qt.defaultLinearOptions={start:{x:0,y:0},end:{x:0,y:1},colorStops:[],textureSpace:"local",type:"linear",textureSize:256,wrapMode:"clamp-to-edge"};Qt.defaultRadialOptions={center:{x:.5,y:.5},innerRadius:0,outerRadius:.5,colorStops:[],scale:1,textureSpace:"local",type:"radial",textureSize:256,wrapMode:"clamp-to-edge"};let pt=Qt;function le(i,t){for(let e=0;e<t.length;e++){const s=t[e];i.addColorStop(s.offset,s.color)}}function de(i,t){const e=Ue.get().createCanvas(i,t),s=e.getContext("2d");return{canvas:e,context:s}}function $s(i){let t=i[0]??{};return(typeof t=="number"||i[1])&&(Ot("8.5.2","use options object instead"),t={type:"linear",start:{x:i[0],y:i[1]},end:{x:i[2],y:i[3]},textureSpace:i[4],textureSize:i[5]??pt.defaultLinearOptions.textureSize}),t}const fe={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class Us{constructor(t,e){this.uid=D("fillPattern"),this.transform=new V,this._styleKey=null,this.texture=t,this.transform.scale(1/t.frame.width,1/t.frame.height),e&&(t.source.style.addressModeU=fe[e].addressModeU,t.source.style.addressModeV=fe[e].addressModeV)}setTransform(t){const e=this.texture;this.transform.copyFrom(t),this.transform.invert(),this.transform.scale(1/e.frame.width,1/e.frame.height),this._styleKey=null}get styleKey(){return this._styleKey?this._styleKey:(this._styleKey=`fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`,this._styleKey)}}var Bt,me;function Hs(){if(me)return Bt;me=1,Bt=e;var i={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},t=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function e(n){var o=[];return n.replace(t,function(a,h,u){var c=h.toLowerCase();for(u=r(u),c=="m"&&u.length>2&&(o.push([h].concat(u.splice(0,2))),c="l",h=h=="m"?"l":"L");;){if(u.length==i[c])return u.unshift(h),o.push(u);if(u.length<i[c])throw new Error("malformed path data");o.push([h].concat(u.splice(0,i[c])))}}),o}var s=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function r(n){var o=n.match(s);return o?o.map(Number):[]}return Bt}var Ns=Hs();const qs=vs(Ns);function js(i,t){const e=qs(i),s=[];let r=null,n=0,o=0;for(let a=0;a<e.length;a++){const h=e[a],u=h[0],c=h;switch(u){case"M":n=c[1],o=c[2],t.moveTo(n,o);break;case"m":n+=c[1],o+=c[2],t.moveTo(n,o);break;case"H":n=c[1],t.lineTo(n,o);break;case"h":n+=c[1],t.lineTo(n,o);break;case"V":o=c[1],t.lineTo(n,o);break;case"v":o+=c[1],t.lineTo(n,o);break;case"L":n=c[1],o=c[2],t.lineTo(n,o);break;case"l":n+=c[1],o+=c[2],t.lineTo(n,o);break;case"C":n=c[5],o=c[6],t.bezierCurveTo(c[1],c[2],c[3],c[4],n,o);break;case"c":t.bezierCurveTo(n+c[1],o+c[2],n+c[3],o+c[4],n+c[5],o+c[6]),n+=c[5],o+=c[6];break;case"S":n=c[3],o=c[4],t.bezierCurveToShort(c[1],c[2],n,o);break;case"s":t.bezierCurveToShort(n+c[1],o+c[2],n+c[3],o+c[4]),n+=c[3],o+=c[4];break;case"Q":n=c[3],o=c[4],t.quadraticCurveTo(c[1],c[2],n,o);break;case"q":t.quadraticCurveTo(n+c[1],o+c[2],n+c[3],o+c[4]),n+=c[3],o+=c[4];break;case"T":n=c[1],o=c[2],t.quadraticCurveToShort(n,o);break;case"t":n+=c[1],o+=c[2],t.quadraticCurveToShort(n,o);break;case"A":n=c[6],o=c[7],t.arcToSvg(c[1],c[2],c[3],c[4],c[5],n,o);break;case"a":n+=c[6],o+=c[7],t.arcToSvg(c[1],c[2],c[3],c[4],c[5],n,o);break;case"Z":case"z":t.closePath(),s.length>0&&(r=s.pop(),r?(n=r.startX,o=r.startY):(n=0,o=0)),r=null;break;default:Z(`Unknown SVG path command: ${u}`)}u!=="Z"&&u!=="z"&&r===null&&(r={startX:n,startY:o},s.push(r))}return t}class Zt{constructor(t=0,e=0,s=0){this.type="circle",this.x=t,this.y=e,this.radius=s}clone(){return new Zt(this.x,this.y,this.radius)}contains(t,e){if(this.radius<=0)return!1;const s=this.radius*this.radius;let r=this.x-t,n=this.y-e;return r*=r,n*=n,r+n<=s}strokeContains(t,e,s,r=.5){if(this.radius===0)return!1;const n=this.x-t,o=this.y-e,a=this.radius,h=(1-r)*s,u=Math.sqrt(n*n+o*o);return u<=a+h&&u>a-(s-h)}getBounds(t){return t||(t=new q),t.x=this.x-this.radius,t.y=this.y-this.radius,t.width=this.radius*2,t.height=this.radius*2,t}copyFrom(t){return this.x=t.x,this.y=t.y,this.radius=t.radius,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class Jt{constructor(t=0,e=0,s=0,r=0){this.type="ellipse",this.x=t,this.y=e,this.halfWidth=s,this.halfHeight=r}clone(){return new Jt(this.x,this.y,this.halfWidth,this.halfHeight)}contains(t,e){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let s=(t-this.x)/this.halfWidth,r=(e-this.y)/this.halfHeight;return s*=s,r*=r,s+r<=1}strokeContains(t,e,s,r=.5){const{halfWidth:n,halfHeight:o}=this;if(n<=0||o<=0)return!1;const a=s*(1-r),h=s-a,u=n-h,c=o-h,d=n+a,f=o+a,l=t-this.x,p=e-this.y,g=l*l/(u*u)+p*p/(c*c),m=l*l/(d*d)+p*p/(f*f);return g>1&&m<=1}getBounds(t){return t||(t=new q),t.x=this.x-this.halfWidth,t.y=this.y-this.halfHeight,t.width=this.halfWidth*2,t.height=this.halfHeight*2,t}copyFrom(t){return this.x=t.x,this.y=t.y,this.halfWidth=t.halfWidth,this.halfHeight=t.halfHeight,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function Ws(i,t,e,s,r,n){const o=i-e,a=t-s,h=r-e,u=n-s,c=o*h+a*u,d=h*h+u*u;let f=-1;d!==0&&(f=c/d);let l,p;f<0?(l=e,p=s):f>1?(l=r,p=n):(l=e+f*h,p=s+f*u);const g=i-l,m=t-p;return g*g+m*m}let Os,Ys;class lt{constructor(...t){this.type="polygon";let e=Array.isArray(t[0])?t[0]:t;if(typeof e[0]!="number"){const s=[];for(let r=0,n=e.length;r<n;r++)s.push(e[r].x,e[r].y);e=s}this.points=e,this.closePath=!0}isClockwise(){let t=0;const e=this.points,s=e.length;for(let r=0;r<s;r+=2){const n=e[r],o=e[r+1],a=e[(r+2)%s],h=e[(r+3)%s];t+=(a-n)*(h+o)}return t<0}containsPolygon(t){const e=this.getBounds(Os),s=t.getBounds(Ys);if(!e.containsRect(s))return!1;const r=t.points;for(let n=0;n<r.length;n+=2){const o=r[n],a=r[n+1];if(!this.contains(o,a))return!1}return!0}clone(){const t=this.points.slice(),e=new lt(t);return e.closePath=this.closePath,e}contains(t,e){let s=!1;const r=this.points.length/2;for(let n=0,o=r-1;n<r;o=n++){const a=this.points[n*2],h=this.points[n*2+1],u=this.points[o*2],c=this.points[o*2+1];h>e!=c>e&&t<(u-a)*((e-h)/(c-h))+a&&(s=!s)}return s}strokeContains(t,e,s,r=.5){const n=s*s,o=n*(1-r),a=n-o,{points:h}=this,u=h.length-(this.closePath?0:2);for(let c=0;c<u;c+=2){const d=h[c],f=h[c+1],l=h[(c+2)%h.length],p=h[(c+3)%h.length],g=Ws(t,e,d,f,l,p),m=Math.sign((l-d)*(e-f)-(p-f)*(t-d));if(g<=(m<0?a:o))return!0}return!1}getBounds(t){t||(t=new q);const e=this.points;let s=1/0,r=-1/0,n=1/0,o=-1/0;for(let a=0,h=e.length;a<h;a+=2){const u=e[a],c=e[a+1];s=u<s?u:s,r=u>r?u:r,n=c<n?c:n,o=c>o?c:o}return t.x=s,t.width=r-s,t.y=n,t.height=o-n,t}copyFrom(t){return this.points=t.points.slice(),this.closePath=t.closePath,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t,e)=>`${t}, ${e}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}const _t=(i,t,e,s,r,n,o)=>{const a=i-e,h=t-s,u=Math.sqrt(a*a+h*h);return u>=r-n&&u<=r+o};class te{constructor(t=0,e=0,s=0,r=0,n=20){this.type="roundedRectangle",this.x=t,this.y=e,this.width=s,this.height=r,this.radius=n}getBounds(t){return t||(t=new q),t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t}clone(){return new te(this.x,this.y,this.width,this.height,this.radius)}copyFrom(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this}copyTo(t){return t.copyFrom(this),t}contains(t,e){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&e>=this.y&&e<=this.y+this.height){const s=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(e>=this.y+s&&e<=this.y+this.height-s||t>=this.x+s&&t<=this.x+this.width-s)return!0;let r=t-(this.x+s),n=e-(this.y+s);const o=s*s;if(r*r+n*n<=o||(r=t-(this.x+this.width-s),r*r+n*n<=o)||(n=e-(this.y+this.height-s),r*r+n*n<=o)||(r=t-(this.x+s),r*r+n*n<=o))return!0}return!1}strokeContains(t,e,s,r=.5){const{x:n,y:o,width:a,height:h,radius:u}=this,c=s*(1-r),d=s-c,f=n+u,l=o+u,p=a-u*2,g=h-u*2,m=n+a,x=o+h;return(t>=n-c&&t<=n+d||t>=m-d&&t<=m+c)&&e>=l&&e<=l+g||(e>=o-c&&e<=o+d||e>=x-d&&e<=x+c)&&t>=f&&t<=f+p?!0:t<f&&e<l&&_t(t,e,f,l,u,d,c)||t>m-u&&e<l&&_t(t,e,m-u,l,u,d,c)||t>m-u&&e>x-u&&_t(t,e,m-u,x-u,u,d,c)||t<f&&e>x-u&&_t(t,e,f,x-u,u,d,c)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}const Xs=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join(`
`);function Ks(i){let t="";for(let e=0;e<i;++e)e>0&&(t+=`
else `),e<i-1&&(t+=`if(test == ${e}.0){}`);return t}function Qs(i,t){if(i===0)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const e=t.createShader(t.FRAGMENT_SHADER);try{for(;;){const s=Xs.replace(/%forloop%/gi,Ks(i));if(t.shaderSource(e,s),t.compileShader(e),!t.getShaderParameter(e,t.COMPILE_STATUS))i=i/2|0;else break}}finally{t.deleteShader(e)}return i}let Q=null;function Ke(){var t;if(Q)return Q;const i=Ne();return Q=i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),Q=Qs(Q,i),(t=i.getExtension("WEBGL_lose_context"))==null||t.loseContext(),Q}const Qe={};function Zs(i,t){let e=2166136261;for(let s=0;s<t;s++)e^=i[s].uid,e=Math.imul(e,16777619),e>>>=0;return Qe[e]||Js(i,t,e)}let Gt=0;function Js(i,t,e){const s={};let r=0;Gt||(Gt=Ke());for(let o=0;o<Gt;o++){const a=o<t?i[o]:N.EMPTY.source;s[r++]=a.source,s[r++]=a.style}const n=new Pt(s);return Qe[e]=n,n}class pe{constructor(t){typeof t=="number"?this.rawBinaryData=new ArrayBuffer(t):t instanceof Uint8Array?this.rawBinaryData=t.buffer:this.rawBinaryData=t,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(t){return this[`${t}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(t){switch(t){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${t} isn't a valid view type`)}}}function ge(i,t){const e=i.byteLength/8|0,s=new Float64Array(i,0,e);new Float64Array(t,0,e).set(s);const n=i.byteLength-e*8;if(n>0){const o=new Uint8Array(i,e*8,n);new Uint8Array(t,e*8,n).set(o)}}const ti={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};function ye(i,t){return t.alphaMode==="no-premultiply-alpha"&&ti[i]||i}class ei{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let t=0;t<this.count;t++){const e=this.textures[t];this.textures[t]=null,this.ids[e.uid]=null}this.count=0}}class si{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.textures=new ei,this.blendMode="normal",this.topology="triangle-strip",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}const Ze=[];let Nt=0;function xe(){return Nt>0?Ze[--Nt]:new si}function be(i){Ze[Nt++]=i}let ot=0;const Je=class vt{constructor(t={}){this.uid=D("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._elements=[],vt.defaultOptions.maxTextures=vt.defaultOptions.maxTextures??Ke(),t={...vt.defaultOptions,...t};const{maxTextures:e,attributesInitialSize:s,indicesInitialSize:r}=t;this.attributeBuffer=new pe(s*4),this.indexBuffer=new Uint16Array(r),this.maxTextures=e}begin(){this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0;for(let t=0;t<this.batchIndex;t++)be(this.batches[t]);this.batchIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(t){this._elements[this.elementSize++]=t,t._indexStart=this.indexSize,t._attributeStart=this.attributeSize,t._batcher=this,this.indexSize+=t.indexSize,this.attributeSize+=t.attributeSize*this.vertexSize}checkAndUpdateTexture(t,e){const s=t._batch.textures.ids[e._source.uid];return!s&&s!==0?!1:(t._textureId=s,t.texture=e,!0)}updateElement(t){this.dirty=!0;const e=this.attributeBuffer;t.packAsQuad?this.packQuadAttributes(t,e.float32View,e.uint32View,t._attributeStart,t._textureId):this.packAttributes(t,e.float32View,e.uint32View,t._attributeStart,t._textureId)}break(t){const e=this._elements;if(!e[this.elementStart])return;let s=xe(),r=s.textures;r.clear();const n=e[this.elementStart];let o=ye(n.blendMode,n.texture._source),a=n.topology;this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const h=this.attributeBuffer.float32View,u=this.attributeBuffer.uint32View,c=this.indexBuffer;let d=this._batchIndexSize,f=this._batchIndexStart,l="startBatch";const p=this.maxTextures;for(let g=this.elementStart;g<this.elementSize;++g){const m=e[g];e[g]=null;const y=m.texture._source,P=ye(m.blendMode,y),S=o!==P||a!==m.topology;if(y._batchTick===ot&&!S){m._textureId=y._textureBindLocation,d+=m.indexSize,m.packAsQuad?(this.packQuadAttributes(m,h,u,m._attributeStart,m._textureId),this.packQuadIndex(c,m._indexStart,m._attributeStart/this.vertexSize)):(this.packAttributes(m,h,u,m._attributeStart,m._textureId),this.packIndex(m,c,m._indexStart,m._attributeStart/this.vertexSize)),m._batch=s;continue}y._batchTick=ot,(r.count>=p||S)&&(this._finishBatch(s,f,d-f,r,o,a,t,l),l="renderBatch",f=d,o=P,a=m.topology,s=xe(),r=s.textures,r.clear(),++ot),m._textureId=y._textureBindLocation=r.count,r.ids[y.uid]=r.count,r.textures[r.count++]=y,m._batch=s,d+=m.indexSize,m.packAsQuad?(this.packQuadAttributes(m,h,u,m._attributeStart,m._textureId),this.packQuadIndex(c,m._indexStart,m._attributeStart/this.vertexSize)):(this.packAttributes(m,h,u,m._attributeStart,m._textureId),this.packIndex(m,c,m._indexStart,m._attributeStart/this.vertexSize))}r.count>0&&(this._finishBatch(s,f,d-f,r,o,a,t,l),f=d,++ot),this.elementStart=this.elementSize,this._batchIndexStart=f,this._batchIndexSize=d}_finishBatch(t,e,s,r,n,o,a,h){t.gpuBindGroup=null,t.bindGroup=null,t.action=h,t.batcher=this,t.textures=r,t.blendMode=n,t.topology=o,t.start=e,t.size=s,++ot,this.batches[this.batchIndex++]=t,a.add(t)}finish(t){this.break(t)}ensureAttributeBuffer(t){t*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(t*4)}ensureIndexBuffer(t){t<=this.indexBuffer.length||this._resizeIndexBuffer(t)}_resizeAttributeBuffer(t){const e=Math.max(t,this.attributeBuffer.size*2),s=new pe(e);ge(this.attributeBuffer.rawBinaryData,s.rawBinaryData),this.attributeBuffer=s}_resizeIndexBuffer(t){const e=this.indexBuffer;let s=Math.max(t,e.length*1.5);s+=s%2;const r=s>65535?new Uint32Array(s):new Uint16Array(s);if(r.BYTES_PER_ELEMENT!==e.BYTES_PER_ELEMENT)for(let n=0;n<e.length;n++)r[n]=e[n];else ge(e.buffer,r.buffer);this.indexBuffer=r}packQuadIndex(t,e,s){t[e]=s+0,t[e+1]=s+1,t[e+2]=s+2,t[e+3]=s+0,t[e+4]=s+2,t[e+5]=s+3}packIndex(t,e,s,r){const n=t.indices,o=t.indexSize,a=t.indexOffset,h=t.attributeOffset;for(let u=0;u<o;u++)e[s++]=r+n[u+a]-h}destroy(){for(let t=0;t<this.batches.length;t++)be(this.batches[t]);this.batches=null;for(let t=0;t<this._elements.length;t++)this._elements[t]._batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};Je.defaultOptions={maxTextures:null,attributesInitialSize:4,indicesInitialSize:6};let ii=Je;var R=(i=>(i[i.MAP_READ=1]="MAP_READ",i[i.MAP_WRITE=2]="MAP_WRITE",i[i.COPY_SRC=4]="COPY_SRC",i[i.COPY_DST=8]="COPY_DST",i[i.INDEX=16]="INDEX",i[i.VERTEX=32]="VERTEX",i[i.UNIFORM=64]="UNIFORM",i[i.STORAGE=128]="STORAGE",i[i.INDIRECT=256]="INDIRECT",i[i.QUERY_RESOLVE=512]="QUERY_RESOLVE",i[i.STATIC=1024]="STATIC",i))(R||{});class ft extends Mt{constructor(t){let{data:e,size:s}=t;const{usage:r,label:n,shrinkToFit:o}=t;super(),this.uid=D("buffer"),this._resourceType="buffer",this._resourceId=D("resource"),this._touched=0,this._updateID=1,this._dataInt32=null,this.shrinkToFit=!0,this.destroyed=!1,e instanceof Array&&(e=new Float32Array(e)),this._data=e,s??(s=e==null?void 0:e.byteLength);const a=!!e;this.descriptor={size:s,usage:r,mappedAtCreation:a,label:n},this.shrinkToFit=o??!0}get data(){return this._data}set data(t){this.setDataWithSize(t,t.length,!0)}get dataInt32(){return this._dataInt32||(this._dataInt32=new Int32Array(this.data.buffer)),this._dataInt32}get static(){return!!(this.descriptor.usage&R.STATIC)}set static(t){t?this.descriptor.usage|=R.STATIC:this.descriptor.usage&=~R.STATIC}setDataWithSize(t,e,s){if(this._updateID++,this._updateSize=e*t.BYTES_PER_ELEMENT,this._data===t){s&&this.emit("update",this);return}const r=this._data;if(this._data=t,this._dataInt32=null,!r||r.length!==t.length){!this.shrinkToFit&&r&&t.byteLength<r.byteLength?s&&this.emit("update",this):(this.descriptor.size=t.byteLength,this._resourceId=D("resource"),this.emit("change",this));return}s&&this.emit("update",this)}update(t){this._updateSize=t??this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function ts(i,t){if(!(i instanceof ft)){let e=t?R.INDEX:R.VERTEX;i instanceof Array&&(t?(i=new Uint32Array(i),e=R.INDEX|R.COPY_DST):(i=new Float32Array(i),e=R.VERTEX|R.COPY_DST)),i=new ft({data:i,label:t?"index-mesh-buffer":"vertex-mesh-buffer",usage:e})}return i}function ri(i,t,e){const s=i.getAttribute(t);if(!s)return e.minX=0,e.minY=0,e.maxX=0,e.maxY=0,e;const r=s.buffer.data;let n=1/0,o=1/0,a=-1/0,h=-1/0;const u=r.BYTES_PER_ELEMENT,c=(s.offset||0)/u,d=(s.stride||2*4)/u;for(let f=c;f<r.length;f+=d){const l=r[f],p=r[f+1];l>a&&(a=l),p>h&&(h=p),l<n&&(n=l),p<o&&(o=p)}return e.minX=n,e.minY=o,e.maxX=a,e.maxY=h,e}function ni(i){return(i instanceof ft||Array.isArray(i)||i.BYTES_PER_ELEMENT)&&(i={buffer:i}),i.buffer=ts(i.buffer,!1),i}class oi extends Mt{constructor(t={}){super(),this.uid=D("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new Yt,this._boundsDirty=!0;const{attributes:e,indexBuffer:s,topology:r}=t;if(this.buffers=[],this.attributes={},e)for(const n in e)this.addAttribute(n,e[n]);this.instanceCount=t.instanceCount??1,s&&this.addIndex(s),this.topology=r||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(t){return this.attributes[t]}getIndex(){return this.indexBuffer}getBuffer(t){return this.getAttribute(t).buffer}getSize(){for(const t in this.attributes){const e=this.attributes[t];return e.buffer.data.length/(e.stride/4||e.size)}return 0}addAttribute(t,e){const s=ni(e);this.buffers.indexOf(s.buffer)===-1&&(this.buffers.push(s.buffer),s.buffer.on("update",this.onBufferUpdate,this),s.buffer.on("change",this.onBufferUpdate,this)),this.attributes[t]=s}addIndex(t){this.indexBuffer=ts(t,!0),this.buffers.push(this.indexBuffer)}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,ri(this,"aPosition",this._bounds)):this._bounds}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners(),t&&this.buffers.forEach(e=>e.destroy()),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}const ai=new Float32Array(1),ci=new Uint32Array(1);class hi extends oi{constructor(){const e=new ft({data:ai,label:"attribute-batch-buffer",usage:R.VERTEX|R.COPY_DST,shrinkToFit:!1}),s=new ft({data:ci,label:"index-batch-buffer",usage:R.INDEX|R.COPY_DST,shrinkToFit:!1}),r=6*4;super({attributes:{aPosition:{buffer:e,format:"float32x2",stride:r,offset:0},aUV:{buffer:e,format:"float32x2",stride:r,offset:2*4},aColor:{buffer:e,format:"unorm8x4",stride:r,offset:4*4},aTextureIdAndRound:{buffer:e,format:"uint16x2",stride:r,offset:5*4}},indexBuffer:s})}}function _e(i,t,e){if(i)for(const s in i){const r=s.toLocaleLowerCase(),n=t[r];if(n){let o=i[s];s==="header"&&(o=o.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),e&&n.push(`//----${e}----//`),n.push(o)}else Z(`${s} placement hook does not exist in shader`)}}const ui=/\{\{(.*?)\}\}/g;function Se(i){var s;const t={};return(((s=i.match(ui))==null?void 0:s.map(r=>r.replace(/[{()}]/g,"")))??[]).forEach(r=>{t[r]=[]}),t}function Pe(i,t){let e;const s=/@in\s+([^;]+);/g;for(;(e=s.exec(i))!==null;)t.push(e[1])}function ve(i,t,e=!1){const s=[];Pe(t,s),i.forEach(a=>{a.header&&Pe(a.header,s)});const r=s;e&&r.sort();const n=r.map((a,h)=>`       @location(${h}) ${a},`).join(`
`);let o=t.replace(/@in\s+[^;]+;\s*/g,"");return o=o.replace("{{in}}",`
${n}
`),o}function Me(i,t){let e;const s=/@out\s+([^;]+);/g;for(;(e=s.exec(i))!==null;)t.push(e[1])}function li(i){const e=/\b(\w+)\s*:/g.exec(i);return e?e[1]:""}function di(i){const t=/@.*?\s+/g;return i.replace(t,"")}function fi(i,t){const e=[];Me(t,e),i.forEach(h=>{h.header&&Me(h.header,e)});let s=0;const r=e.sort().map(h=>h.indexOf("builtin")>-1?h:`@location(${s++}) ${h}`).join(`,
`),n=e.sort().map(h=>`       var ${di(h)};`).join(`
`),o=`return VSOutput(
            ${e.sort().map(h=>` ${li(h)}`).join(`,
`)});`;let a=t.replace(/@out\s+[^;]+;\s*/g,"");return a=a.replace("{{struct}}",`
${r}
`),a=a.replace("{{start}}",`
${n}
`),a=a.replace("{{return}}",`
${o}
`),a}function we(i,t){let e=i;for(const s in t){const r=t[s];r.join(`
`).length?e=e.replace(`{{${s}}}`,`//-----${s} START-----//
${r.join(`
`)}
//----${s} FINISH----//`):e=e.replace(`{{${s}}}`,"")}return e}const U=Object.create(null),Rt=new Map;let mi=0;function pi({template:i,bits:t}){const e=es(i,t);if(U[e])return U[e];const{vertex:s,fragment:r}=yi(i,t);return U[e]=ss(s,r,t),U[e]}function gi({template:i,bits:t}){const e=es(i,t);return U[e]||(U[e]=ss(i.vertex,i.fragment,t)),U[e]}function yi(i,t){const e=t.map(o=>o.vertex).filter(o=>!!o),s=t.map(o=>o.fragment).filter(o=>!!o);let r=ve(e,i.vertex,!0);r=fi(e,r);const n=ve(s,i.fragment,!0);return{vertex:r,fragment:n}}function es(i,t){return t.map(e=>(Rt.has(e)||Rt.set(e,mi++),Rt.get(e))).sort((e,s)=>e-s).join("-")+i.vertex+i.fragment}function ss(i,t,e){const s=Se(i),r=Se(t);return e.forEach(n=>{_e(n.vertex,s,n.name),_e(n.fragment,r,n.name)}),{vertex:we(i,s),fragment:we(t,r)}}const xi=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,bi=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,_i=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,Si=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`,Pi={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},vi={name:"global-uniforms-bit",vertex:{header:`
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}};function Mi({bits:i,name:t}){const e=pi({template:{fragment:bi,vertex:xi},bits:[Pi,...i]});return wt.from({name:t,vertex:{source:e.vertex,entryPoint:"main"},fragment:{source:e.fragment,entryPoint:"main"}})}function wi({bits:i,name:t}){return new je({name:t,...gi({template:{vertex:_i,fragment:Si},bits:[vi,...i]})})}const Ti={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},Ci={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},Dt={};function ki(i){const t=[];if(i===1)t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),t.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let e=0;for(let s=0;s<i;s++)t.push(`@group(1) @binding(${e++}) var textureSource${s+1}: texture_2d<f32>;`),t.push(`@group(1) @binding(${e++}) var textureSampler${s+1}: sampler;`)}return t.join(`
`)}function Ii(i){const t=[];if(i===1)t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{t.push("switch vTextureId {");for(let e=0;e<i;e++)e===i-1?t.push("  default:{"):t.push(`  case ${e}:{`),t.push(`      outColor = textureSampleGrad(textureSource${e+1}, textureSampler${e+1}, vUV, uvDx, uvDy);`),t.push("      break;}");t.push("}")}return t.join(`
`)}function Ai(i){return Dt[i]||(Dt[i]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;

                ${ki(i)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Ii(i)}
            `}}),Dt[i]}const Ft={};function zi(i){const t=[];for(let e=0;e<i;e++)e>0&&t.push("else"),e<i-1&&t.push(`if(vTextureId < ${e}.5)`),t.push("{"),t.push(`	outColor = texture(uTextures[${e}], vUV);`),t.push("}");return t.join(`
`)}function Ei(i){return Ft[i]||(Ft[i]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,main:`

                ${zi(i)}
            `}}),Ft[i]}const Bi={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},Gi={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},Te={};function Ri(i){let t=Te[i];if(t)return t;const e=new Int32Array(i);for(let s=0;s<i;s++)e[s]=s;return t=Te[i]=new Xe({uTextures:{value:e,type:"i32",size:i}},{isStatic:!0}),t}class Di extends Kt{constructor(t){const e=wi({name:"batch",bits:[Ci,Ei(t),Gi]}),s=Mi({name:"batch",bits:[Ti,Ai(t),Bi]});super({glProgram:e,gpuProgram:s,resources:{batchSamplers:Ri(t)}})}}let Ce=null;const is=class rs extends ii{constructor(){super(...arguments),this.geometry=new hi,this.shader=Ce||(Ce=new Di(this.maxTextures)),this.name=rs.extension.name,this.vertexSize=6}packAttributes(t,e,s,r,n){const o=n<<16|t.roundPixels&65535,a=t.transform,h=a.a,u=a.b,c=a.c,d=a.d,f=a.tx,l=a.ty,{positions:p,uvs:g}=t,m=t.color,x=t.attributeOffset,y=x+t.attributeSize;for(let P=x;P<y;P++){const S=P*2,M=p[S],b=p[S+1];e[r++]=h*M+c*b+f,e[r++]=d*b+u*M+l,e[r++]=g[S],e[r++]=g[S+1],s[r++]=m,s[r++]=o}}packQuadAttributes(t,e,s,r,n){const o=t.texture,a=t.transform,h=a.a,u=a.b,c=a.c,d=a.d,f=a.tx,l=a.ty,p=t.bounds,g=p.maxX,m=p.minX,x=p.maxY,y=p.minY,P=o.uvs,S=t.color,M=n<<16|t.roundPixels&65535;e[r+0]=h*m+c*y+f,e[r+1]=d*y+u*m+l,e[r+2]=P.x0,e[r+3]=P.y0,s[r+4]=S,s[r+5]=M,e[r+6]=h*g+c*y+f,e[r+7]=d*y+u*g+l,e[r+8]=P.x1,e[r+9]=P.y1,s[r+10]=S,s[r+11]=M,e[r+12]=h*g+c*x+f,e[r+13]=d*x+u*g+l,e[r+14]=P.x2,e[r+15]=P.y2,s[r+16]=S,s[r+17]=M,e[r+18]=h*m+c*x+f,e[r+19]=d*x+u*m+l,e[r+20]=P.x3,e[r+21]=P.y3,s[r+22]=S,s[r+23]=M}};is.extension={type:[L.Batcher],name:"default"};let Fi=is;function Vi(i,t,e,s,r,n,o,a=null){let h=0;e*=t,r*=n;const u=a.a,c=a.b,d=a.c,f=a.d,l=a.tx,p=a.ty;for(;h<o;){const g=i[e],m=i[e+1];s[r]=u*g+d*m+l,s[r+1]=c*g+f*m+p,r+=n,e+=t,h++}}function Li(i,t,e,s){let r=0;for(t*=e;r<s;)i[t]=0,i[t+1]=0,t+=e,r++}function ns(i,t,e,s,r){const n=t.a,o=t.b,a=t.c,h=t.d,u=t.tx,c=t.ty;e||(e=0),s||(s=2),r||(r=i.length/s-e);let d=e*s;for(let f=0;f<r;f++){const l=i[d],p=i[d+1];i[d]=n*l+a*p+u,i[d+1]=o*l+h*p+c,d+=s}}const $i=new V;class os{constructor(){this.packAsQuad=!1,this.batcherName="default",this.topology="triangle-list",this.applyTransform=!0,this.roundPixels=0,this._batcher=null,this._batch=null}get uvs(){return this.geometryData.uvs}get positions(){return this.geometryData.vertices}get indices(){return this.geometryData.indices}get blendMode(){return this.applyTransform?this.renderable.groupBlendMode:"normal"}get color(){const t=this.baseColor,e=t>>16|t&65280|(t&255)<<16,s=this.renderable;return s?xs(e,s.groupColor)+(this.alpha*s.groupAlpha*255<<24):e+(this.alpha*255<<24)}get transform(){var t;return((t=this.renderable)==null?void 0:t.groupTransform)||$i}copyTo(t){t.indexOffset=this.indexOffset,t.indexSize=this.indexSize,t.attributeOffset=this.attributeOffset,t.attributeSize=this.attributeSize,t.baseColor=this.baseColor,t.alpha=this.alpha,t.texture=this.texture,t.geometryData=this.geometryData,t.topology=this.topology}reset(){this.applyTransform=!0,this.renderable=null,this.topology="triangle-list"}}const mt={extension:{type:L.ShapeBuilder,name:"circle"},build(i,t){let e,s,r,n,o,a;if(i.type==="circle"){const S=i;e=S.x,s=S.y,o=a=S.radius,r=n=0}else if(i.type==="ellipse"){const S=i;e=S.x,s=S.y,o=S.halfWidth,a=S.halfHeight,r=n=0}else{const S=i,M=S.width/2,b=S.height/2;e=S.x+M,s=S.y+b,o=a=Math.max(0,Math.min(S.radius,Math.min(M,b))),r=M-o,n=b-a}if(!(o>=0&&a>=0&&r>=0&&n>=0))return t;const h=Math.ceil(2.3*Math.sqrt(o+a)),u=h*8+(r?4:0)+(n?4:0);if(u===0)return t;if(h===0)return t[0]=t[6]=e+r,t[1]=t[3]=s+n,t[2]=t[4]=e-r,t[5]=t[7]=s-n,t;let c=0,d=h*4+(r?2:0)+2,f=d,l=u,p=r+o,g=n,m=e+p,x=e-p,y=s+g;if(t[c++]=m,t[c++]=y,t[--d]=y,t[--d]=x,n){const S=s-g;t[f++]=x,t[f++]=S,t[--l]=S,t[--l]=m}for(let S=1;S<h;S++){const M=Math.PI/2*(S/h),b=r+Math.cos(M)*o,_=n+Math.sin(M)*a,I=e+b,k=e-b,v=s+_,w=s-_;t[c++]=I,t[c++]=v,t[--d]=v,t[--d]=k,t[f++]=k,t[f++]=w,t[--l]=w,t[--l]=I}p=r,g=n+a,m=e+p,x=e-p,y=s+g;const P=s-g;return t[c++]=m,t[c++]=y,t[--l]=P,t[--l]=m,r&&(t[c++]=x,t[c++]=y,t[--l]=P,t[--l]=x),t},triangulate(i,t,e,s,r,n){if(i.length===0)return;let o=0,a=0;for(let c=0;c<i.length;c+=2)o+=i[c],a+=i[c+1];o/=i.length/2,a/=i.length/2;let h=s;t[h*e]=o,t[h*e+1]=a;const u=h++;for(let c=0;c<i.length;c+=2)t[h*e]=i[c],t[h*e+1]=i[c+1],c>0&&(r[n++]=h,r[n++]=u,r[n++]=h-1),h++;r[n++]=u+1,r[n++]=u,r[n++]=h-1}},Ui={...mt,extension:{...mt.extension,name:"ellipse"}},Hi={...mt,extension:{...mt.extension,name:"roundedRectangle"}},as=1e-4,ke=1e-4;function Ni(i){const t=i.length;if(t<6)return 1;let e=0;for(let s=0,r=i[t-2],n=i[t-1];s<t;s+=2){const o=i[s],a=i[s+1];e+=(o-r)*(a+n),r=o,n=a}return e<0?-1:1}function Ie(i,t,e,s,r,n,o,a){const h=i-e*r,u=t-s*r,c=i+e*n,d=t+s*n;let f,l;o?(f=s,l=-e):(f=-s,l=e);const p=h+f,g=u+l,m=c+f,x=d+l;return a.push(p,g),a.push(m,x),2}function X(i,t,e,s,r,n,o,a){const h=e-i,u=s-t;let c=Math.atan2(h,u),d=Math.atan2(r-i,n-t);a&&c<d?c+=Math.PI*2:!a&&c>d&&(d+=Math.PI*2);let f=c;const l=d-c,p=Math.abs(l),g=Math.sqrt(h*h+u*u),m=(15*p*Math.sqrt(g)/Math.PI>>0)+1,x=l/m;if(f+=x,a){o.push(i,t),o.push(e,s);for(let y=1,P=f;y<m;y++,P+=x)o.push(i,t),o.push(i+Math.sin(P)*g,t+Math.cos(P)*g);o.push(i,t),o.push(r,n)}else{o.push(e,s),o.push(i,t);for(let y=1,P=f;y<m;y++,P+=x)o.push(i+Math.sin(P)*g,t+Math.cos(P)*g),o.push(i,t);o.push(r,n),o.push(i,t)}return m*2}function qi(i,t,e,s,r,n){const o=as;if(i.length===0)return;const a=t;let h=a.alignment;if(t.alignment!==.5){let A=Ni(i);h=(h-.5)*A+.5}const u=new J(i[0],i[1]),c=new J(i[i.length-2],i[i.length-1]),d=s,f=Math.abs(u.x-c.x)<o&&Math.abs(u.y-c.y)<o;if(d){i=i.slice(),f&&(i.pop(),i.pop(),c.set(i[i.length-2],i[i.length-1]));const A=(u.x+c.x)*.5,$=(c.y+u.y)*.5;i.unshift(A,$),i.push(A,$)}const l=r,p=i.length/2;let g=i.length;const m=l.length/2,x=a.width/2,y=x*x,P=a.miterLimit*a.miterLimit;let S=i[0],M=i[1],b=i[2],_=i[3],I=0,k=0,v=-(M-_),w=S-b,z=0,E=0,G=Math.sqrt(v*v+w*w);v/=G,w/=G,v*=x,w*=x;const et=h,T=(1-et)*2,C=et*2;d||(a.cap==="round"?g+=X(S-v*(T-C)*.5,M-w*(T-C)*.5,S-v*T,M-w*T,S+v*C,M+w*C,l,!0)+2:a.cap==="square"&&(g+=Ie(S,M,v,w,T,C,!0,l))),l.push(S-v*T,M-w*T),l.push(S+v*C,M+w*C);for(let A=1;A<p-1;++A){S=i[(A-1)*2],M=i[(A-1)*2+1],b=i[A*2],_=i[A*2+1],I=i[(A+1)*2],k=i[(A+1)*2+1],v=-(M-_),w=S-b,G=Math.sqrt(v*v+w*w),v/=G,w/=G,v*=x,w*=x,z=-(_-k),E=b-I,G=Math.sqrt(z*z+E*E),z/=G,E/=G,z*=x,E*=x;const $=b-S,st=M-_,it=b-I,rt=k-_,ie=$*it+st*rt,gt=st*it-rt*$,nt=gt<0;if(Math.abs(gt)<.001*Math.abs(ie)){l.push(b-v*T,_-w*T),l.push(b+v*C,_+w*C),ie>=0&&(a.join==="round"?g+=X(b,_,b-v*T,_-w*T,b-z*T,_-E*T,l,!1)+4:g+=2,l.push(b-z*C,_-E*C),l.push(b+z*T,_+E*T));continue}const re=(-v+S)*(-w+_)-(-v+b)*(-w+M),ne=(-z+I)*(-E+_)-(-z+b)*(-E+k),yt=($*ne-it*re)/gt,xt=(rt*re-st*ne)/gt,Ct=(yt-b)*(yt-b)+(xt-_)*(xt-_),j=b+(yt-b)*T,W=_+(xt-_)*T,O=b-(yt-b)*C,Y=_-(xt-_)*C,ps=Math.min($*$+st*st,it*it+rt*rt),oe=nt?T:C,gs=ps+oe*oe*y;Ct<=gs?a.join==="bevel"||Ct/y>P?(nt?(l.push(j,W),l.push(b+v*C,_+w*C),l.push(j,W),l.push(b+z*C,_+E*C)):(l.push(b-v*T,_-w*T),l.push(O,Y),l.push(b-z*T,_-E*T),l.push(O,Y)),g+=2):a.join==="round"?nt?(l.push(j,W),l.push(b+v*C,_+w*C),g+=X(b,_,b+v*C,_+w*C,b+z*C,_+E*C,l,!0)+4,l.push(j,W),l.push(b+z*C,_+E*C)):(l.push(b-v*T,_-w*T),l.push(O,Y),g+=X(b,_,b-v*T,_-w*T,b-z*T,_-E*T,l,!1)+4,l.push(b-z*T,_-E*T),l.push(O,Y)):(l.push(j,W),l.push(O,Y)):(l.push(b-v*T,_-w*T),l.push(b+v*C,_+w*C),a.join==="round"?nt?g+=X(b,_,b+v*C,_+w*C,b+z*C,_+E*C,l,!0)+2:g+=X(b,_,b-v*T,_-w*T,b-z*T,_-E*T,l,!1)+2:a.join==="miter"&&Ct/y<=P&&(nt?(l.push(O,Y),l.push(O,Y)):(l.push(j,W),l.push(j,W)),g+=2),l.push(b-z*T,_-E*T),l.push(b+z*C,_+E*C),g+=2)}S=i[(p-2)*2],M=i[(p-2)*2+1],b=i[(p-1)*2],_=i[(p-1)*2+1],v=-(M-_),w=S-b,G=Math.sqrt(v*v+w*w),v/=G,w/=G,v*=x,w*=x,l.push(b-v*T,_-w*T),l.push(b+v*C,_+w*C),d||(a.cap==="round"?g+=X(b-v*(T-C)*.5,_-w*(T-C)*.5,b-v*T,_-w*T,b+v*C,_+w*C,l,!1)+2:a.cap==="square"&&(g+=Ie(b,_,v,w,T,C,!1,l)));const ms=ke*ke;for(let A=m;A<g+m-2;++A)S=l[A*2],M=l[A*2+1],b=l[(A+1)*2],_=l[(A+1)*2+1],I=l[(A+2)*2],k=l[(A+2)*2+1],!(Math.abs(S*(_-k)+b*(k-M)+I*(M-_))<ms)&&n.push(A,A+1,A+2)}function ji(i,t,e,s){const r=as;if(i.length===0)return;const n=i[0],o=i[1],a=i[i.length-2],h=i[i.length-1],u=t||Math.abs(n-a)<r&&Math.abs(o-h)<r,c=e,d=i.length/2,f=c.length/2;for(let l=0;l<d;l++)c.push(i[l*2]),c.push(i[l*2+1]);for(let l=0;l<d-1;l++)s.push(f+l,f+l+1);u&&s.push(f+d-1,f)}function cs(i,t,e,s,r,n,o){const a=bs(i,t,2);if(!a)return;for(let u=0;u<a.length;u+=3)n[o++]=a[u]+r,n[o++]=a[u+1]+r,n[o++]=a[u+2]+r;let h=r*s;for(let u=0;u<i.length;u+=2)e[h]=i[u],e[h+1]=i[u+1],h+=s}const Wi=[],Oi={extension:{type:L.ShapeBuilder,name:"polygon"},build(i,t){for(let e=0;e<i.points.length;e++)t[e]=i.points[e];return t},triangulate(i,t,e,s,r,n){cs(i,Wi,t,e,s,r,n)}},Yi={extension:{type:L.ShapeBuilder,name:"rectangle"},build(i,t){const e=i,s=e.x,r=e.y,n=e.width,o=e.height;return n>=0&&o>=0&&(t[0]=s,t[1]=r,t[2]=s+n,t[3]=r,t[4]=s+n,t[5]=r+o,t[6]=s,t[7]=r+o),t},triangulate(i,t,e,s,r,n){let o=0;s*=e,t[s+o]=i[0],t[s+o+1]=i[1],o+=e,t[s+o]=i[2],t[s+o+1]=i[3],o+=e,t[s+o]=i[6],t[s+o+1]=i[7],o+=e,t[s+o]=i[4],t[s+o+1]=i[5],o+=e;const a=s/e;r[n++]=a,r[n++]=a+1,r[n++]=a+2,r[n++]=a+1,r[n++]=a+3,r[n++]=a+2}},Xi={extension:{type:L.ShapeBuilder,name:"triangle"},build(i,t){return t[0]=i.x,t[1]=i.y,t[2]=i.x2,t[3]=i.y2,t[4]=i.x3,t[5]=i.y3,t},triangulate(i,t,e,s,r,n){let o=0;s*=e,t[s+o]=i[0],t[s+o+1]=i[1],o+=e,t[s+o]=i[2],t[s+o+1]=i[3],o+=e,t[s+o]=i[4],t[s+o+1]=i[5];const a=s/e;r[n++]=a,r[n++]=a+1,r[n++]=a+2}},Ki=new V,Qi=new q;function Zi(i,t,e,s){const r=t.matrix?i.copyFrom(t.matrix).invert():i.identity();if(t.textureSpace==="local"){const o=e.getBounds(Qi);t.width&&o.pad(t.width);const{x:a,y:h}=o,u=1/o.width,c=1/o.height,d=-a*u,f=-h*c,l=r.a,p=r.b,g=r.c,m=r.d;r.a*=u,r.b*=u,r.c*=c,r.d*=c,r.tx=d*l+f*g+r.tx,r.ty=d*p+f*m+r.ty}else r.translate(t.texture.frame.x,t.texture.frame.y),r.scale(1/t.texture.source.width,1/t.texture.source.height);const n=t.texture.source.style;return!(t.fill instanceof pt)&&n.addressMode==="clamp-to-edge"&&(n.addressMode="repeat",n.update()),s&&r.append(Ki.copyFrom(s).invert()),r}const Tt={};He.handleByMap(L.ShapeBuilder,Tt);He.add(Yi,Oi,Xi,mt,Ui,Hi);const Ji=new q,tr=new V;function er(i,t){const{geometryData:e,batches:s}=t;s.length=0,e.indices.length=0,e.vertices.length=0,e.uvs.length=0;for(let r=0;r<i.instructions.length;r++){const n=i.instructions[r];if(n.action==="texture")sr(n.data,s,e);else if(n.action==="fill"||n.action==="stroke"){const o=n.action==="stroke",a=n.data.path.shapePath,h=n.data.style,u=n.data.hole;o&&u&&Ae(u.shapePath,h,!0,s,e),u&&(a.shapePrimitives[a.shapePrimitives.length-1].holes=u.shapePath.shapePrimitives),Ae(a,h,o,s,e)}}}function sr(i,t,e){const{vertices:s,uvs:r,indices:n}=e,o=n.length,a=s.length/2,h=[],u=Tt.rectangle,c=Ji,d=i.image;c.x=i.dx,c.y=i.dy,c.width=i.dw,c.height=i.dh;const f=i.transform;u.build(c,h),f&&ns(h,f),u.triangulate(h,s,2,a,n,o);const l=d.uvs;r.push(l.x0,l.y0,l.x1,l.y1,l.x3,l.y3,l.x2,l.y2);const p=ut.get(os);p.indexOffset=o,p.indexSize=n.length-o,p.attributeOffset=a,p.attributeSize=s.length/2-a,p.baseColor=i.style,p.alpha=i.alpha,p.texture=d,p.geometryData=e,t.push(p)}function Ae(i,t,e,s,r){const{vertices:n,uvs:o,indices:a}=r;i.shapePrimitives.forEach(({shape:h,transform:u,holes:c})=>{const d=a.length,f=n.length/2,l=[],p=Tt[h.type];let g="triangle-list";if(p.build(h,l),u&&ns(l,u),e){const P=h.closePath??!0,S=t;S.pixelLine?(ji(l,P,n,a),g="line-list"):qi(l,S,!1,P,n,a)}else if(c){const P=[],S=l.slice();ir(c).forEach(b=>{P.push(S.length/2),S.push(...b)}),cs(S,P,n,2,f,a,d)}else p.triangulate(l,n,2,f,a,d);const m=o.length/2,x=t.texture;if(x!==N.WHITE){const P=Zi(tr,t,h,u);Vi(n,2,f,o,m,2,n.length/2-f,P)}else Li(o,m,2,n.length/2-f);const y=ut.get(os);y.indexOffset=d,y.indexSize=a.length-d,y.attributeOffset=f,y.attributeSize=n.length/2-f,y.baseColor=t.color,y.alpha=t.alpha,y.texture=x,y.geometryData=r,y.topology=g,s.push(y)})}function ir(i){const t=[];for(let e=0;e<i.length;e++){const s=i[e].shape,r=[];Tt[s.type].build(s,r),t.push(r)}return t}class rr{constructor(){this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}}class nr{constructor(){this.batcher=new Fi,this.instructions=new _s}init(){this.instructions.reset()}get geometry(){return Ot(Ss,"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."),this.batcher.geometry}}const ee=class qt{constructor(t){this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null),t.renderableGC.addManagedHash(this,"_gpuContextHash"),t.renderableGC.addManagedHash(this,"_graphicsDataContextHash")}init(t){qt.defaultOptions.bezierSmoothness=(t==null?void 0:t.bezierSmoothness)??qt.defaultOptions.bezierSmoothness}getContextRenderData(t){return this._graphicsDataContextHash[t.uid]||this._initContextRenderData(t)}updateGpuContext(t){let e=this._gpuContextHash[t.uid]||this._initContext(t);if(t.dirty){e?this._cleanGraphicsContextData(t):e=this._initContext(t),er(t,e);const s=t.batchMode;t.customShader||s==="no-batch"?e.isBatchable=!1:s==="auto"&&(e.isBatchable=e.geometryData.vertices.length<400),t.dirty=!1}return e}getGpuContext(t){return this._gpuContextHash[t.uid]||this._initContext(t)}_initContextRenderData(t){const e=ut.get(nr),{batches:s,geometryData:r}=this._gpuContextHash[t.uid],n=r.vertices.length,o=r.indices.length;for(let c=0;c<s.length;c++)s[c].applyTransform=!1;const a=e.batcher;a.ensureAttributeBuffer(n),a.ensureIndexBuffer(o),a.begin();for(let c=0;c<s.length;c++){const d=s[c];a.add(d)}a.finish(e.instructions);const h=a.geometry;h.indexBuffer.setDataWithSize(a.indexBuffer,a.indexSize,!0),h.buffers[0].setDataWithSize(a.attributeBuffer.float32View,a.attributeSize,!0);const u=a.batches;for(let c=0;c<u.length;c++){const d=u[c];d.bindGroup=Zs(d.textures.textures,d.textures.count)}return this._graphicsDataContextHash[t.uid]=e,e}_initContext(t){const e=new rr;return e.context=t,this._gpuContextHash[t.uid]=e,t.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]}onGraphicsContextDestroy(t){this._cleanGraphicsContextData(t),t.off("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]=null}_cleanGraphicsContextData(t){const e=this._gpuContextHash[t.uid];e.isBatchable||this._graphicsDataContextHash[t.uid]&&(ut.return(this.getContextRenderData(t)),this._graphicsDataContextHash[t.uid]=null),e.batches&&e.batches.forEach(s=>{ut.return(s)})}destroy(){for(const t in this._gpuContextHash)this._gpuContextHash[t]&&this.onGraphicsContextDestroy(this._gpuContextHash[t].context)}};ee.extension={type:[L.WebGLSystem,L.WebGPUSystem,L.CanvasSystem],name:"graphicsContext"};ee.defaultOptions={bezierSmoothness:.5};let hs=ee;const or=8,St=11920929e-14,ar=1;function us(i,t,e,s,r,n,o,a,h,u){const d=Math.min(.99,Math.max(0,u??hs.defaultOptions.bezierSmoothness));let f=(ar-d)/1;return f*=f,cr(t,e,s,r,n,o,a,h,i,f),i}function cr(i,t,e,s,r,n,o,a,h,u){jt(i,t,e,s,r,n,o,a,h,u,0),h.push(o,a)}function jt(i,t,e,s,r,n,o,a,h,u,c){if(c>or)return;const d=(i+e)/2,f=(t+s)/2,l=(e+r)/2,p=(s+n)/2,g=(r+o)/2,m=(n+a)/2,x=(d+l)/2,y=(f+p)/2,P=(l+g)/2,S=(p+m)/2,M=(x+P)/2,b=(y+S)/2;if(c>0){let _=o-i,I=a-t;const k=Math.abs((e-o)*I-(s-a)*_),v=Math.abs((r-o)*I-(n-a)*_);if(k>St&&v>St){if((k+v)*(k+v)<=u*(_*_+I*I)){h.push(M,b);return}}else if(k>St){if(k*k<=u*(_*_+I*I)){h.push(M,b);return}}else if(v>St){if(v*v<=u*(_*_+I*I)){h.push(M,b);return}}else if(_=M-(i+o)/2,I=b-(t+a)/2,_*_+I*I<=u){h.push(M,b);return}}jt(i,t,d,f,x,y,M,b,h,u,c+1),jt(M,b,P,S,g,m,o,a,h,u,c+1)}const hr=8,ur=11920929e-14,lr=1;function dr(i,t,e,s,r,n,o,a){const u=Math.min(.99,Math.max(0,a??hs.defaultOptions.bezierSmoothness));let c=(lr-u)/1;return c*=c,fr(t,e,s,r,n,o,i,c),i}function fr(i,t,e,s,r,n,o,a){Wt(o,i,t,e,s,r,n,a,0),o.push(r,n)}function Wt(i,t,e,s,r,n,o,a,h){if(h>hr)return;const u=(t+s)/2,c=(e+r)/2,d=(s+n)/2,f=(r+o)/2,l=(u+d)/2,p=(c+f)/2;let g=n-t,m=o-e;const x=Math.abs((s-n)*m-(r-o)*g);if(x>ur){if(x*x<=a*(g*g+m*m)){i.push(l,p);return}}else if(g=l-(t+n)/2,m=p-(e+o)/2,g*g+m*m<=a){i.push(l,p);return}Wt(i,t,e,u,c,l,p,a,h+1),Wt(i,l,p,d,f,n,o,a,h+1)}function ls(i,t,e,s,r,n,o,a){let h=Math.abs(r-n);(!o&&r>n||o&&n>r)&&(h=2*Math.PI-h),a||(a=Math.max(6,Math.floor(6*Math.pow(s,1/3)*(h/Math.PI)))),a=Math.max(a,3);let u=h/a,c=r;u*=o?-1:1;for(let d=0;d<a+1;d++){const f=Math.cos(c),l=Math.sin(c),p=t+f*s,g=e+l*s;i.push(p,g),c+=u}}function mr(i,t,e,s,r,n){const o=i[i.length-2],h=i[i.length-1]-e,u=o-t,c=r-e,d=s-t,f=Math.abs(h*d-u*c);if(f<1e-8||n===0){(i[i.length-2]!==t||i[i.length-1]!==e)&&i.push(t,e);return}const l=h*h+u*u,p=c*c+d*d,g=h*c+u*d,m=n*Math.sqrt(l)/f,x=n*Math.sqrt(p)/f,y=m*g/l,P=x*g/p,S=m*d+x*u,M=m*c+x*h,b=u*(x+y),_=h*(x+y),I=d*(m+P),k=c*(m+P),v=Math.atan2(_-M,b-S),w=Math.atan2(k-M,I-S);ls(i,S+t,M+e,n,v,w,u*c>d*h)}const dt=Math.PI*2,Vt={centerX:0,centerY:0,ang1:0,ang2:0},Lt=({x:i,y:t},e,s,r,n,o,a,h)=>{i*=e,t*=s;const u=r*i-n*t,c=n*i+r*t;return h.x=u+o,h.y=c+a,h};function pr(i,t){const e=t===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(t/4),s=t===1.5707963267948966?.551915024494:e,r=Math.cos(i),n=Math.sin(i),o=Math.cos(i+t),a=Math.sin(i+t);return[{x:r-n*s,y:n+r*s},{x:o+a*s,y:a-o*s},{x:o,y:a}]}const ze=(i,t,e,s)=>{const r=i*s-t*e<0?-1:1;let n=i*e+t*s;return n>1&&(n=1),n<-1&&(n=-1),r*Math.acos(n)},gr=(i,t,e,s,r,n,o,a,h,u,c,d,f)=>{const l=Math.pow(r,2),p=Math.pow(n,2),g=Math.pow(c,2),m=Math.pow(d,2);let x=l*p-l*m-p*g;x<0&&(x=0),x/=l*m+p*g,x=Math.sqrt(x)*(o===a?-1:1);const y=x*r/n*d,P=x*-n/r*c,S=u*y-h*P+(i+e)/2,M=h*y+u*P+(t+s)/2,b=(c-y)/r,_=(d-P)/n,I=(-c-y)/r,k=(-d-P)/n,v=ze(1,0,b,_);let w=ze(b,_,I,k);a===0&&w>0&&(w-=dt),a===1&&w<0&&(w+=dt),f.centerX=S,f.centerY=M,f.ang1=v,f.ang2=w};function yr(i,t,e,s,r,n,o,a=0,h=0,u=0){if(n===0||o===0)return;const c=Math.sin(a*dt/360),d=Math.cos(a*dt/360),f=d*(t-s)/2+c*(e-r)/2,l=-c*(t-s)/2+d*(e-r)/2;if(f===0&&l===0)return;n=Math.abs(n),o=Math.abs(o);const p=Math.pow(f,2)/Math.pow(n,2)+Math.pow(l,2)/Math.pow(o,2);p>1&&(n*=Math.sqrt(p),o*=Math.sqrt(p)),gr(t,e,s,r,n,o,h,u,c,d,f,l,Vt);let{ang1:g,ang2:m}=Vt;const{centerX:x,centerY:y}=Vt;let P=Math.abs(m)/(dt/4);Math.abs(1-P)<1e-7&&(P=1);const S=Math.max(Math.ceil(P),1);m/=S;let M=i[i.length-2],b=i[i.length-1];const _={x:0,y:0};for(let I=0;I<S;I++){const k=pr(g,m),{x:v,y:w}=Lt(k[0],n,o,d,c,x,y,_),{x:z,y:E}=Lt(k[1],n,o,d,c,x,y,_),{x:G,y:et}=Lt(k[2],n,o,d,c,x,y,_);us(i,M,b,v,w,z,E,G,et),M=G,b=et,g+=m}}function xr(i,t,e){const s=(o,a)=>{const h=a.x-o.x,u=a.y-o.y,c=Math.sqrt(h*h+u*u),d=h/c,f=u/c;return{len:c,nx:d,ny:f}},r=(o,a)=>{o===0?i.moveTo(a.x,a.y):i.lineTo(a.x,a.y)};let n=t[t.length-1];for(let o=0;o<t.length;o++){const a=t[o%t.length],h=a.radius??e;if(h<=0){r(o,a),n=a;continue}const u=t[(o+1)%t.length],c=s(a,n),d=s(a,u);if(c.len<1e-4||d.len<1e-4){r(o,a),n=a;continue}let f=Math.asin(c.nx*d.ny-c.ny*d.nx),l=1,p=!1;c.nx*d.nx-c.ny*-d.ny<0?f<0?f=Math.PI+f:(f=Math.PI-f,l=-1,p=!0):f>0&&(l=-1,p=!0);const g=f/2;let m,x=Math.abs(Math.cos(g)*h/Math.sin(g));x>Math.min(c.len/2,d.len/2)?(x=Math.min(c.len/2,d.len/2),m=Math.abs(x*Math.sin(g)/Math.cos(g))):m=h;const y=a.x+d.nx*x+-d.ny*m*l,P=a.y+d.ny*x+d.nx*m*l,S=Math.atan2(c.ny,c.nx)+Math.PI/2*l,M=Math.atan2(d.ny,d.nx)-Math.PI/2*l;o===0&&i.moveTo(y+Math.cos(S)*m,P+Math.sin(S)*m),i.arc(y,P,m,S,M,p),n=a}}function br(i,t,e,s){const r=(a,h)=>Math.sqrt((a.x-h.x)**2+(a.y-h.y)**2),n=(a,h,u)=>({x:a.x+(h.x-a.x)*u,y:a.y+(h.y-a.y)*u}),o=t.length;for(let a=0;a<o;a++){const h=t[(a+1)%o],u=h.radius??e;if(u<=0){a===0?i.moveTo(h.x,h.y):i.lineTo(h.x,h.y);continue}const c=t[a],d=t[(a+2)%o],f=r(c,h);let l;if(f<1e-4)l=h;else{const m=Math.min(f/2,u);l=n(h,c,m/f)}const p=r(d,h);let g;if(p<1e-4)g=h;else{const m=Math.min(p/2,u);g=n(h,d,m/p)}a===0?i.moveTo(l.x,l.y):i.lineTo(l.x,l.y),i.quadraticCurveTo(h.x,h.y,g.x,g.y,s)}}const _r=new q;class Sr{constructor(t){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Yt,this._graphicsPath2D=t,this.signed=t.checkForHoles}moveTo(t,e){return this.startPoly(t,e),this}lineTo(t,e){this._ensurePoly();const s=this._currentPoly.points,r=s[s.length-2],n=s[s.length-1];return(r!==t||n!==e)&&s.push(t,e),this}arc(t,e,s,r,n,o){this._ensurePoly(!1);const a=this._currentPoly.points;return ls(a,t,e,s,r,n,o),this}arcTo(t,e,s,r,n){this._ensurePoly();const o=this._currentPoly.points;return mr(o,t,e,s,r,n),this}arcToSvg(t,e,s,r,n,o,a){const h=this._currentPoly.points;return yr(h,this._currentPoly.lastX,this._currentPoly.lastY,o,a,t,e,s,r,n),this}bezierCurveTo(t,e,s,r,n,o,a){this._ensurePoly();const h=this._currentPoly;return us(this._currentPoly.points,h.lastX,h.lastY,t,e,s,r,n,o,a),this}quadraticCurveTo(t,e,s,r,n){this._ensurePoly();const o=this._currentPoly;return dr(this._currentPoly.points,o.lastX,o.lastY,t,e,s,r,n),this}closePath(){return this.endPoly(!0),this}addPath(t,e){this.endPoly(),e&&!e.isIdentity()&&(t=t.clone(!0),t.transform(e));const s=this.shapePrimitives,r=s.length;for(let n=0;n<t.instructions.length;n++){const o=t.instructions[n];this[o.action](...o.data)}if(t.checkForHoles&&s.length-r>1){let n=null;for(let o=r;o<s.length;o++){const a=s[o];if(a.shape.type==="polygon"){const h=a.shape,u=n==null?void 0:n.shape;u&&u.containsPolygon(h)?(n.holes||(n.holes=[]),n.holes.push(a),s.copyWithin(o,o+1),s.length--,o--):n=a}}}return this}finish(t=!1){this.endPoly(t)}rect(t,e,s,r,n){return this.drawShape(new q(t,e,s,r),n),this}circle(t,e,s,r){return this.drawShape(new Zt(t,e,s),r),this}poly(t,e,s){const r=new lt(t);return r.closePath=e,this.drawShape(r,s),this}regularPoly(t,e,s,r,n=0,o){r=Math.max(r|0,3);const a=-1*Math.PI/2+n,h=Math.PI*2/r,u=[];for(let c=0;c<r;c++){const d=a-c*h;u.push(t+s*Math.cos(d),e+s*Math.sin(d))}return this.poly(u,!0,o),this}roundPoly(t,e,s,r,n,o=0,a){if(r=Math.max(r|0,3),n<=0)return this.regularPoly(t,e,s,r,o);const h=s*Math.sin(Math.PI/r)-.001;n=Math.min(n,h);const u=-1*Math.PI/2+o,c=Math.PI*2/r,d=(r-2)*Math.PI/r/2;for(let f=0;f<r;f++){const l=f*c+u,p=t+s*Math.cos(l),g=e+s*Math.sin(l),m=l+Math.PI+d,x=l-Math.PI-d,y=p+n*Math.cos(m),P=g+n*Math.sin(m),S=p+n*Math.cos(x),M=g+n*Math.sin(x);f===0?this.moveTo(y,P):this.lineTo(y,P),this.quadraticCurveTo(p,g,S,M,a)}return this.closePath()}roundShape(t,e,s=!1,r){return t.length<3?this:(s?br(this,t,e,r):xr(this,t,e),this.closePath())}filletRect(t,e,s,r,n){if(n===0)return this.rect(t,e,s,r);const o=Math.min(s,r)/2,a=Math.min(o,Math.max(-o,n)),h=t+s,u=e+r,c=a<0?-a:0,d=Math.abs(a);return this.moveTo(t,e+d).arcTo(t+c,e+c,t+d,e,d).lineTo(h-d,e).arcTo(h-c,e+c,h,e+d,d).lineTo(h,u-d).arcTo(h-c,u-c,t+s-d,u,d).lineTo(t+d,u).arcTo(t+c,u-c,t,u-d,d).closePath()}chamferRect(t,e,s,r,n,o){if(n<=0)return this.rect(t,e,s,r);const a=Math.min(n,Math.min(s,r)/2),h=t+s,u=e+r,c=[t+a,e,h-a,e,h,e+a,h,u-a,h-a,u,t+a,u,t,u-a,t,e+a];for(let d=c.length-1;d>=2;d-=2)c[d]===c[d-2]&&c[d-1]===c[d-3]&&c.splice(d-1,2);return this.poly(c,!0,o)}ellipse(t,e,s,r,n){return this.drawShape(new Jt(t,e,s,r),n),this}roundRect(t,e,s,r,n,o){return this.drawShape(new te(t,e,s,r,n),o),this}drawShape(t,e){return this.endPoly(),this.shapePrimitives.push({shape:t,transform:e}),this}startPoly(t,e){let s=this._currentPoly;return s&&this.endPoly(),s=new lt,s.points.push(t,e),this._currentPoly=s,this}endPoly(t=!1){const e=this._currentPoly;return e&&e.points.length>2&&(e.closePath=t,this.shapePrimitives.push({shape:e})),this._currentPoly=null,this}_ensurePoly(t=!0){if(!this._currentPoly&&(this._currentPoly=new lt,t)){const e=this.shapePrimitives[this.shapePrimitives.length-1];if(e){let s=e.shape.x,r=e.shape.y;if(e.transform&&!e.transform.isIdentity()){const n=e.transform,o=s;s=n.a*s+n.c*r+n.tx,r=n.b*o+n.d*r+n.ty}this._currentPoly.points.push(s,r)}else this._currentPoly.points.push(0,0)}}buildPath(){const t=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let e=0;e<t.instructions.length;e++){const s=t.instructions[e];this[s.action](...s.data)}this.finish()}get bounds(){const t=this._bounds;t.clear();const e=this.shapePrimitives;for(let s=0;s<e.length;s++){const r=e[s],n=r.shape.getBounds(_r);r.transform?t.addRect(n,r.transform):t.addRect(n)}return t}}class tt{constructor(t,e=!1){this.instructions=[],this.uid=D("graphicsPath"),this._dirty=!0,this.checkForHoles=e,typeof t=="string"?js(t,this):this.instructions=(t==null?void 0:t.slice())??[]}get shapePath(){return this._shapePath||(this._shapePath=new Sr(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(t,e){return t=t.clone(),this.instructions.push({action:"addPath",data:[t,e]}),this._dirty=!0,this}arc(...t){return this.instructions.push({action:"arc",data:t}),this._dirty=!0,this}arcTo(...t){return this.instructions.push({action:"arcTo",data:t}),this._dirty=!0,this}arcToSvg(...t){return this.instructions.push({action:"arcToSvg",data:t}),this._dirty=!0,this}bezierCurveTo(...t){return this.instructions.push({action:"bezierCurveTo",data:t}),this._dirty=!0,this}bezierCurveToShort(t,e,s,r,n){const o=this.instructions[this.instructions.length-1],a=this.getLastPoint(J.shared);let h=0,u=0;if(!o||o.action!=="bezierCurveTo")h=a.x,u=a.y;else{h=o.data[2],u=o.data[3];const c=a.x,d=a.y;h=c+(c-h),u=d+(d-u)}return this.instructions.push({action:"bezierCurveTo",data:[h,u,t,e,s,r,n]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...t){return this.instructions.push({action:"ellipse",data:t}),this._dirty=!0,this}lineTo(...t){return this.instructions.push({action:"lineTo",data:t}),this._dirty=!0,this}moveTo(...t){return this.instructions.push({action:"moveTo",data:t}),this}quadraticCurveTo(...t){return this.instructions.push({action:"quadraticCurveTo",data:t}),this._dirty=!0,this}quadraticCurveToShort(t,e,s){const r=this.instructions[this.instructions.length-1],n=this.getLastPoint(J.shared);let o=0,a=0;if(!r||r.action!=="quadraticCurveTo")o=n.x,a=n.y;else{o=r.data[0],a=r.data[1];const h=n.x,u=n.y;o=h+(h-o),a=u+(u-a)}return this.instructions.push({action:"quadraticCurveTo",data:[o,a,t,e,s]}),this._dirty=!0,this}rect(t,e,s,r,n){return this.instructions.push({action:"rect",data:[t,e,s,r,n]}),this._dirty=!0,this}circle(t,e,s,r){return this.instructions.push({action:"circle",data:[t,e,s,r]}),this._dirty=!0,this}roundRect(...t){return this.instructions.push({action:"roundRect",data:t}),this._dirty=!0,this}poly(...t){return this.instructions.push({action:"poly",data:t}),this._dirty=!0,this}regularPoly(...t){return this.instructions.push({action:"regularPoly",data:t}),this._dirty=!0,this}roundPoly(...t){return this.instructions.push({action:"roundPoly",data:t}),this._dirty=!0,this}roundShape(...t){return this.instructions.push({action:"roundShape",data:t}),this._dirty=!0,this}filletRect(...t){return this.instructions.push({action:"filletRect",data:t}),this._dirty=!0,this}chamferRect(...t){return this.instructions.push({action:"chamferRect",data:t}),this._dirty=!0,this}star(t,e,s,r,n,o,a){n||(n=r/2);const h=-1*Math.PI/2+o,u=s*2,c=Math.PI*2/u,d=[];for(let f=0;f<u;f++){const l=f%2?n:r,p=f*c+h;d.push(t+l*Math.cos(p),e+l*Math.sin(p))}return this.poly(d,!0,a),this}clone(t=!1){const e=new tt;if(e.checkForHoles=this.checkForHoles,!t)e.instructions=this.instructions.slice();else for(let s=0;s<this.instructions.length;s++){const r=this.instructions[s];e.instructions.push({action:r.action,data:r.data.slice()})}return e}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(t){if(t.isIdentity())return this;const e=t.a,s=t.b,r=t.c,n=t.d,o=t.tx,a=t.ty;let h=0,u=0,c=0,d=0,f=0,l=0,p=0,g=0;for(let m=0;m<this.instructions.length;m++){const x=this.instructions[m],y=x.data;switch(x.action){case"moveTo":case"lineTo":h=y[0],u=y[1],y[0]=e*h+r*u+o,y[1]=s*h+n*u+a;break;case"bezierCurveTo":c=y[0],d=y[1],f=y[2],l=y[3],h=y[4],u=y[5],y[0]=e*c+r*d+o,y[1]=s*c+n*d+a,y[2]=e*f+r*l+o,y[3]=s*f+n*l+a,y[4]=e*h+r*u+o,y[5]=s*h+n*u+a;break;case"quadraticCurveTo":c=y[0],d=y[1],h=y[2],u=y[3],y[0]=e*c+r*d+o,y[1]=s*c+n*d+a,y[2]=e*h+r*u+o,y[3]=s*h+n*u+a;break;case"arcToSvg":h=y[5],u=y[6],p=y[0],g=y[1],y[0]=e*p+r*g,y[1]=s*p+n*g,y[5]=e*h+r*u+o,y[6]=s*h+n*u+a;break;case"circle":y[4]=at(y[3],t);break;case"rect":y[4]=at(y[4],t);break;case"ellipse":y[8]=at(y[8],t);break;case"roundRect":y[5]=at(y[5],t);break;case"addPath":y[0].transform(t);break;case"poly":y[2]=at(y[2],t);break;default:Z("unknown transform action",x.action);break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(t){let e=this.instructions.length-1,s=this.instructions[e];if(!s)return t.x=0,t.y=0,t;for(;s.action==="closePath";){if(e--,e<0)return t.x=0,t.y=0,t;s=this.instructions[e]}switch(s.action){case"moveTo":case"lineTo":t.x=s.data[0],t.y=s.data[1];break;case"quadraticCurveTo":t.x=s.data[2],t.y=s.data[3];break;case"bezierCurveTo":t.x=s.data[4],t.y=s.data[5];break;case"arc":case"arcToSvg":t.x=s.data[5],t.y=s.data[6];break;case"addPath":s.data[0].getLastPoint(t);break}return t}}function at(i,t){return i?i.prepend(t):t.clone()}function B(i,t,e){const s=i.getAttribute(t);return s?Number(s):e}function Pr(i,t){const e=i.querySelectorAll("defs");for(let s=0;s<e.length;s++){const r=e[s];for(let n=0;n<r.children.length;n++){const o=r.children[n];switch(o.nodeName.toLowerCase()){case"lineargradient":t.defs[o.id]=vr(o);break;case"radialgradient":t.defs[o.id]=Mr();break}}}}function vr(i){const t=B(i,"x1",0),e=B(i,"y1",0),s=B(i,"x2",1),r=B(i,"y2",0),n=i.getAttribute("gradientUnits")||"objectBoundingBox",o=new pt(t,e,s,r,n==="objectBoundingBox"?"local":"global");for(let a=0;a<i.children.length;a++){const h=i.children[a],u=B(h,"offset",0),c=H.shared.setValue(h.getAttribute("stop-color")).toNumber();o.addColorStop(u,c)}return o}function Mr(i){return Z("[SVG Parser] Radial gradients are not yet supported"),new pt(0,0,1,0)}function Ee(i){const t=i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);return t?t[1]:""}const Be={fill:{type:"paint",default:0},"fill-opacity":{type:"number",default:1},stroke:{type:"paint",default:0},"stroke-width":{type:"number",default:1},"stroke-opacity":{type:"number",default:1},"stroke-linecap":{type:"string",default:"butt"},"stroke-linejoin":{type:"string",default:"miter"},"stroke-miterlimit":{type:"number",default:10},"stroke-dasharray":{type:"string",default:"none"},"stroke-dashoffset":{type:"number",default:0},opacity:{type:"number",default:1}};function ds(i,t){const e=i.getAttribute("style"),s={},r={},n={strokeStyle:s,fillStyle:r,useFill:!1,useStroke:!1};for(const o in Be){const a=i.getAttribute(o);a&&Ge(t,n,o,a.trim())}if(e){const o=e.split(";");for(let a=0;a<o.length;a++){const h=o[a].trim(),[u,c]=h.split(":");Be[u]&&Ge(t,n,u,c.trim())}}return{strokeStyle:n.useStroke?s:null,fillStyle:n.useFill?r:null,useFill:n.useFill,useStroke:n.useStroke}}function Ge(i,t,e,s){switch(e){case"stroke":if(s!=="none"){if(s.startsWith("url(")){const r=Ee(s);t.strokeStyle.fill=i.defs[r]}else t.strokeStyle.color=H.shared.setValue(s).toNumber();t.useStroke=!0}break;case"stroke-width":t.strokeStyle.width=Number(s);break;case"fill":if(s!=="none"){if(s.startsWith("url(")){const r=Ee(s);t.fillStyle.fill=i.defs[r]}else t.fillStyle.color=H.shared.setValue(s).toNumber();t.useFill=!0}break;case"fill-opacity":t.fillStyle.alpha=Number(s);break;case"stroke-opacity":t.strokeStyle.alpha=Number(s);break;case"opacity":t.fillStyle.alpha=Number(s),t.strokeStyle.alpha=Number(s);break}}function wr(i,t){if(typeof i=="string"){const o=document.createElement("div");o.innerHTML=i.trim(),i=o.querySelector("svg")}const e={context:t,defs:{},path:new tt};Pr(i,e);const s=i.children,{fillStyle:r,strokeStyle:n}=ds(i,e);for(let o=0;o<s.length;o++){const a=s[o];a.nodeName.toLowerCase()!=="defs"&&fs(a,e,r,n)}return t}function fs(i,t,e,s){const r=i.children,{fillStyle:n,strokeStyle:o}=ds(i,t);n&&e?e={...e,...n}:n&&(e=n),o&&s?s={...s,...o}:o&&(s=o);const a=!e&&!s;a&&(e={color:0});let h,u,c,d,f,l,p,g,m,x,y,P,S,M,b,_,I;switch(i.nodeName.toLowerCase()){case"path":M=i.getAttribute("d"),i.getAttribute("fill-rule")==="evenodd"&&Z("SVG Evenodd fill rule not supported, your svg may render incorrectly"),b=new tt(M,!0),t.context.path(b),e&&t.context.fill(e),s&&t.context.stroke(s);break;case"circle":p=B(i,"cx",0),g=B(i,"cy",0),m=B(i,"r",0),t.context.ellipse(p,g,m,m),e&&t.context.fill(e),s&&t.context.stroke(s);break;case"rect":h=B(i,"x",0),u=B(i,"y",0),_=B(i,"width",0),I=B(i,"height",0),x=B(i,"rx",0),y=B(i,"ry",0),x||y?t.context.roundRect(h,u,_,I,x||y):t.context.rect(h,u,_,I),e&&t.context.fill(e),s&&t.context.stroke(s);break;case"ellipse":p=B(i,"cx",0),g=B(i,"cy",0),x=B(i,"rx",0),y=B(i,"ry",0),t.context.beginPath(),t.context.ellipse(p,g,x,y),e&&t.context.fill(e),s&&t.context.stroke(s);break;case"line":c=B(i,"x1",0),d=B(i,"y1",0),f=B(i,"x2",0),l=B(i,"y2",0),t.context.beginPath(),t.context.moveTo(c,d),t.context.lineTo(f,l),s&&t.context.stroke(s);break;case"polygon":S=i.getAttribute("points"),P=S.match(/\d+/g).map(k=>parseInt(k,10)),t.context.poly(P,!0),e&&t.context.fill(e),s&&t.context.stroke(s);break;case"polyline":S=i.getAttribute("points"),P=S.match(/\d+/g).map(k=>parseInt(k,10)),t.context.poly(P,!1),s&&t.context.stroke(s);break;case"g":case"svg":break;default:{Z(`[SVG parser] <${i.nodeName}> elements unsupported`);break}}a&&(e=null);for(let k=0;k<r.length;k++)fs(r[k],t,e,s)}function Tr(i){return H.isColorLike(i)}function Re(i){return i instanceof Us}function De(i){return i instanceof pt}function Cr(i){return i instanceof N}function kr(i,t,e){const s=H.shared.setValue(t??0);return i.color=s.toNumber(),i.alpha=s.alpha===1?e.alpha:s.alpha,i.texture=N.WHITE,{...e,...i}}function Ir(i,t,e){return i.texture=t,{...e,...i}}function Fe(i,t,e){return i.fill=t,i.color=16777215,i.texture=t.texture,i.matrix=t.transform,{...e,...i}}function Ve(i,t,e){return t.buildGradient(),i.fill=t,i.color=16777215,i.texture=t.texture,i.matrix=t.transform,i.textureSpace=t.textureSpace,{...e,...i}}function Ar(i,t){const e={...t,...i},s=H.shared.setValue(e.color);return e.alpha*=s.alpha,e.color=s.toNumber(),e}function ht(i,t){if(i==null)return null;const e={},s=i;return Tr(i)?kr(e,i,t):Cr(i)?Ir(e,i,t):Re(i)?Fe(e,i,t):De(i)?Ve(e,i,t):s.fill&&Re(s.fill)?Fe(s,s.fill,t):s.fill&&De(s.fill)?Ve(s,s.fill,t):Ar(s,t)}function Le(i,t){const{width:e,alignment:s,miterLimit:r,cap:n,join:o,pixelLine:a,...h}=t,u=ht(i,h);return u?{width:e,alignment:s,miterLimit:r,cap:n,join:o,pixelLine:a,...u}:null}const zr=new J,$e=new V,se=class F extends Mt{constructor(){super(...arguments),this.uid=D("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new tt,this._transform=new V,this._fillStyle={...F.defaultFillStyle},this._strokeStyle={...F.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new Yt,this._boundsDirty=!0}clone(){const t=new F;return t.batchMode=this.batchMode,t.instructions=this.instructions.slice(),t._activePath=this._activePath.clone(),t._transform=this._transform.clone(),t._fillStyle={...this._fillStyle},t._strokeStyle={...this._strokeStyle},t._stateStack=this._stateStack.slice(),t._bounds=this._bounds.clone(),t._boundsDirty=!0,t}get fillStyle(){return this._fillStyle}set fillStyle(t){this._fillStyle=ht(t,F.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(t){this._strokeStyle=Le(t,F.defaultStrokeStyle)}setFillStyle(t){return this._fillStyle=ht(t,F.defaultFillStyle),this}setStrokeStyle(t){return this._strokeStyle=ht(t,F.defaultStrokeStyle),this}texture(t,e,s,r,n,o){return this.instructions.push({action:"texture",data:{image:t,dx:s||0,dy:r||0,dw:n||t.frame.width,dh:o||t.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:e?H.shared.setValue(e).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new tt,this}fill(t,e){let s;const r=this.instructions[this.instructions.length-1];return this._tick===0&&r&&r.action==="stroke"?s=r.data.path:s=this._activePath.clone(),s?(t!=null&&(e!==void 0&&typeof t=="number"&&(Ot(Ps,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),t={color:t,alpha:e}),this._fillStyle=ht(t,F.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:s}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:t,y:e}=this._activePath.getLastPoint(J.shared);this._activePath.clear(),this._activePath.moveTo(t,e)}stroke(t){let e;const s=this.instructions[this.instructions.length-1];return this._tick===0&&s&&s.action==="fill"?e=s.data.path:e=this._activePath.clone(),e?(t!=null&&(this._strokeStyle=Le(t,F.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:e}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let t=0;t<2;t++){const e=this.instructions[this.instructions.length-1-t],s=this._activePath.clone();if(e&&(e.action==="stroke"||e.action==="fill"))if(e.data.hole)e.data.hole.addPath(s);else{e.data.hole=s;break}}return this._initNextPathLocation(),this}arc(t,e,s,r,n,o){this._tick++;const a=this._transform;return this._activePath.arc(a.a*t+a.c*e+a.tx,a.b*t+a.d*e+a.ty,s,r,n,o),this}arcTo(t,e,s,r,n){this._tick++;const o=this._transform;return this._activePath.arcTo(o.a*t+o.c*e+o.tx,o.b*t+o.d*e+o.ty,o.a*s+o.c*r+o.tx,o.b*s+o.d*r+o.ty,n),this}arcToSvg(t,e,s,r,n,o,a){this._tick++;const h=this._transform;return this._activePath.arcToSvg(t,e,s,r,n,h.a*o+h.c*a+h.tx,h.b*o+h.d*a+h.ty),this}bezierCurveTo(t,e,s,r,n,o,a){this._tick++;const h=this._transform;return this._activePath.bezierCurveTo(h.a*t+h.c*e+h.tx,h.b*t+h.d*e+h.ty,h.a*s+h.c*r+h.tx,h.b*s+h.d*r+h.ty,h.a*n+h.c*o+h.tx,h.b*n+h.d*o+h.ty,a),this}closePath(){var t;return this._tick++,(t=this._activePath)==null||t.closePath(),this}ellipse(t,e,s,r){return this._tick++,this._activePath.ellipse(t,e,s,r,this._transform.clone()),this}circle(t,e,s){return this._tick++,this._activePath.circle(t,e,s,this._transform.clone()),this}path(t){return this._tick++,this._activePath.addPath(t,this._transform.clone()),this}lineTo(t,e){this._tick++;const s=this._transform;return this._activePath.lineTo(s.a*t+s.c*e+s.tx,s.b*t+s.d*e+s.ty),this}moveTo(t,e){this._tick++;const s=this._transform,r=this._activePath.instructions,n=s.a*t+s.c*e+s.tx,o=s.b*t+s.d*e+s.ty;return r.length===1&&r[0].action==="moveTo"?(r[0].data[0]=n,r[0].data[1]=o,this):(this._activePath.moveTo(n,o),this)}quadraticCurveTo(t,e,s,r,n){this._tick++;const o=this._transform;return this._activePath.quadraticCurveTo(o.a*t+o.c*e+o.tx,o.b*t+o.d*e+o.ty,o.a*s+o.c*r+o.tx,o.b*s+o.d*r+o.ty,n),this}rect(t,e,s,r){return this._tick++,this._activePath.rect(t,e,s,r,this._transform.clone()),this}roundRect(t,e,s,r,n){return this._tick++,this._activePath.roundRect(t,e,s,r,n,this._transform.clone()),this}poly(t,e){return this._tick++,this._activePath.poly(t,e,this._transform.clone()),this}regularPoly(t,e,s,r,n=0,o){return this._tick++,this._activePath.regularPoly(t,e,s,r,n,o),this}roundPoly(t,e,s,r,n,o){return this._tick++,this._activePath.roundPoly(t,e,s,r,n,o),this}roundShape(t,e,s,r){return this._tick++,this._activePath.roundShape(t,e,s,r),this}filletRect(t,e,s,r,n){return this._tick++,this._activePath.filletRect(t,e,s,r,n),this}chamferRect(t,e,s,r,n,o){return this._tick++,this._activePath.chamferRect(t,e,s,r,n,o),this}star(t,e,s,r,n=0,o=0){return this._tick++,this._activePath.star(t,e,s,r,n,o,this._transform.clone()),this}svg(t){return this._tick++,wr(t,this),this}restore(){const t=this._stateStack.pop();return t&&(this._transform=t.transform,this._fillStyle=t.fillStyle,this._strokeStyle=t.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(t){return this._transform.rotate(t),this}scale(t,e=t){return this._transform.scale(t,e),this}setTransform(t,e,s,r,n,o){return t instanceof V?(this._transform.set(t.a,t.b,t.c,t.d,t.tx,t.ty),this):(this._transform.set(t,e,s,r,n,o),this)}transform(t,e,s,r,n,o){return t instanceof V?(this._transform.append(t),this):($e.set(t,e,s,r,n,o),this._transform.append($e),this)}translate(t,e=t){return this._transform.translate(t,e),this}clear(){return this._activePath.clear(),this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const t=this._bounds;t.clear();for(let e=0;e<this.instructions.length;e++){const s=this.instructions[e],r=s.action;if(r==="fill"){const n=s.data;t.addBounds(n.path.bounds)}else if(r==="texture"){const n=s.data;t.addFrame(n.dx,n.dy,n.dx+n.dw,n.dy+n.dh,n.transform)}if(r==="stroke"){const n=s.data,o=n.style.alignment,a=n.style.width*(1-o),h=n.path.bounds;t.addFrame(h.minX-a,h.minY-a,h.maxX+a,h.maxY+a)}}return t}containsPoint(t){var r;if(!this.bounds.containsPoint(t.x,t.y))return!1;const e=this.instructions;let s=!1;for(let n=0;n<e.length;n++){const o=e[n],a=o.data,h=a.path;if(!o.action||!h)continue;const u=a.style,c=h.shapePath.shapePrimitives;for(let d=0;d<c.length;d++){const f=c[d].shape;if(!u||!f)continue;const l=c[d].transform,p=l?l.applyInverse(t,zr):t;if(o.action==="fill")s=f.contains(p.x,p.y);else{const m=u;s=f.strokeContains(p.x,p.y,m.width,m.alignment)}const g=a.hole;if(g){const m=(r=g.shapePath)==null?void 0:r.shapePrimitives;if(m)for(let x=0;x<m.length;x++)m[x].shape.contains(p.x,p.y)&&(s=!1)}if(s)return!0}}return s}destroy(t=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof t=="boolean"?t:t==null?void 0:t.texture){const s=typeof t=="boolean"?t:t==null?void 0:t.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(s),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(s)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};se.defaultFillStyle={color:16777215,alpha:1,texture:N.WHITE,matrix:null,fill:null,textureSpace:"local"};se.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:N.WHITE,matrix:null,fill:null,textureSpace:"local",pixelLine:!1};let Rr=se;export{Pt as B,pt as F,Rr as G,Ut as R,Kt as S,Xe as U,pe as V,Le as a,Us as b,wt as c,je as d,oi as e,ft as f,R as g,os as h,ye as i,Es as j,Mi as k,wi as l,Gi as m,Ke as n,Ti as o,Ai as p,Ci as q,Bi as r,Ei as s,ht as t,Ri as u,hs as v};
